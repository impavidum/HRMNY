module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCard {
  count: Int!
}

type AggregateDashboard {
  count: Int!
}

type AggregateDay {
  count: Int!
}

type AggregateEntity {
  count: Int!
}

type AggregateGrouping {
  count: Int!
}

type AggregateHour {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregateLayoutLG {
  count: Int!
}

type AggregateLayoutMD {
  count: Int!
}

type AggregateLayoutSM {
  count: Int!
}

type AggregateLayoutXS {
  count: Int!
}

type AggregateMonth {
  count: Int!
}

type AggregateQuarter {
  count: Int!
}

type AggregateWeek {
  count: Int!
}

type AggregateYear {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Card {
  id: ID!
  cardType: CardType
  title: String
  layoutLG: LayoutLG!
  layoutMD: LayoutMD!
  layoutSM: LayoutSM!
  layoutXS: LayoutXS!
  grouping: Grouping!
}

type CardConnection {
  pageInfo: PageInfo!
  edges: [CardEdge]!
  aggregate: AggregateCard!
}

input CardCreateInput {
  id: ID
  cardType: CardType
  title: String
  layoutLG: LayoutLGCreateOneWithoutCardInput!
  layoutMD: LayoutMDCreateOneWithoutCardInput!
  layoutSM: LayoutSMCreateOneWithoutCardInput!
  layoutXS: LayoutXSCreateOneWithoutCardInput!
  grouping: GroupingCreateOneWithoutCardsInput!
}

input CardCreateManyWithoutGroupingInput {
  create: [CardCreateWithoutGroupingInput!]
  connect: [CardWhereUniqueInput!]
}

input CardCreateOneWithoutLayoutLGInput {
  create: CardCreateWithoutLayoutLGInput
  connect: CardWhereUniqueInput
}

input CardCreateOneWithoutLayoutMDInput {
  create: CardCreateWithoutLayoutMDInput
  connect: CardWhereUniqueInput
}

input CardCreateOneWithoutLayoutSMInput {
  create: CardCreateWithoutLayoutSMInput
  connect: CardWhereUniqueInput
}

input CardCreateOneWithoutLayoutXSInput {
  create: CardCreateWithoutLayoutXSInput
  connect: CardWhereUniqueInput
}

input CardCreateWithoutGroupingInput {
  id: ID
  cardType: CardType
  title: String
  layoutLG: LayoutLGCreateOneWithoutCardInput!
  layoutMD: LayoutMDCreateOneWithoutCardInput!
  layoutSM: LayoutSMCreateOneWithoutCardInput!
  layoutXS: LayoutXSCreateOneWithoutCardInput!
}

input CardCreateWithoutLayoutLGInput {
  id: ID
  cardType: CardType
  title: String
  layoutMD: LayoutMDCreateOneWithoutCardInput!
  layoutSM: LayoutSMCreateOneWithoutCardInput!
  layoutXS: LayoutXSCreateOneWithoutCardInput!
  grouping: GroupingCreateOneWithoutCardsInput!
}

input CardCreateWithoutLayoutMDInput {
  id: ID
  cardType: CardType
  title: String
  layoutLG: LayoutLGCreateOneWithoutCardInput!
  layoutSM: LayoutSMCreateOneWithoutCardInput!
  layoutXS: LayoutXSCreateOneWithoutCardInput!
  grouping: GroupingCreateOneWithoutCardsInput!
}

input CardCreateWithoutLayoutSMInput {
  id: ID
  cardType: CardType
  title: String
  layoutLG: LayoutLGCreateOneWithoutCardInput!
  layoutMD: LayoutMDCreateOneWithoutCardInput!
  layoutXS: LayoutXSCreateOneWithoutCardInput!
  grouping: GroupingCreateOneWithoutCardsInput!
}

input CardCreateWithoutLayoutXSInput {
  id: ID
  cardType: CardType
  title: String
  layoutLG: LayoutLGCreateOneWithoutCardInput!
  layoutMD: LayoutMDCreateOneWithoutCardInput!
  layoutSM: LayoutSMCreateOneWithoutCardInput!
  grouping: GroupingCreateOneWithoutCardsInput!
}

type CardEdge {
  node: Card!
  cursor: String!
}

enum CardOrderByInput {
  id_ASC
  id_DESC
  cardType_ASC
  cardType_DESC
  title_ASC
  title_DESC
}

type CardPreviousValues {
  id: ID!
  cardType: CardType
  title: String
}

input CardScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  cardType: CardType
  cardType_not: CardType
  cardType_in: [CardType!]
  cardType_not_in: [CardType!]
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [CardScalarWhereInput!]
  OR: [CardScalarWhereInput!]
  NOT: [CardScalarWhereInput!]
}

type CardSubscriptionPayload {
  mutation: MutationType!
  node: Card
  updatedFields: [String!]
  previousValues: CardPreviousValues
}

input CardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CardWhereInput
  AND: [CardSubscriptionWhereInput!]
  OR: [CardSubscriptionWhereInput!]
  NOT: [CardSubscriptionWhereInput!]
}

enum CardType {
  MONTHBAR
  WEEKDENSITY
  WEEKBAR
  FILTER
  TRIGGERLIST
  STACKEDSEVERITY
}

input CardUpdateInput {
  cardType: CardType
  title: String
  layoutLG: LayoutLGUpdateOneRequiredWithoutCardInput
  layoutMD: LayoutMDUpdateOneRequiredWithoutCardInput
  layoutSM: LayoutSMUpdateOneRequiredWithoutCardInput
  layoutXS: LayoutXSUpdateOneRequiredWithoutCardInput
  grouping: GroupingUpdateOneRequiredWithoutCardsInput
}

input CardUpdateManyDataInput {
  cardType: CardType
  title: String
}

input CardUpdateManyMutationInput {
  cardType: CardType
  title: String
}

input CardUpdateManyWithoutGroupingInput {
  create: [CardCreateWithoutGroupingInput!]
  delete: [CardWhereUniqueInput!]
  connect: [CardWhereUniqueInput!]
  set: [CardWhereUniqueInput!]
  disconnect: [CardWhereUniqueInput!]
  update: [CardUpdateWithWhereUniqueWithoutGroupingInput!]
  upsert: [CardUpsertWithWhereUniqueWithoutGroupingInput!]
  deleteMany: [CardScalarWhereInput!]
  updateMany: [CardUpdateManyWithWhereNestedInput!]
}

input CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput!
  data: CardUpdateManyDataInput!
}

input CardUpdateOneRequiredWithoutLayoutLGInput {
  create: CardCreateWithoutLayoutLGInput
  update: CardUpdateWithoutLayoutLGDataInput
  upsert: CardUpsertWithoutLayoutLGInput
  connect: CardWhereUniqueInput
}

input CardUpdateOneRequiredWithoutLayoutMDInput {
  create: CardCreateWithoutLayoutMDInput
  update: CardUpdateWithoutLayoutMDDataInput
  upsert: CardUpsertWithoutLayoutMDInput
  connect: CardWhereUniqueInput
}

input CardUpdateOneRequiredWithoutLayoutSMInput {
  create: CardCreateWithoutLayoutSMInput
  update: CardUpdateWithoutLayoutSMDataInput
  upsert: CardUpsertWithoutLayoutSMInput
  connect: CardWhereUniqueInput
}

input CardUpdateOneRequiredWithoutLayoutXSInput {
  create: CardCreateWithoutLayoutXSInput
  update: CardUpdateWithoutLayoutXSDataInput
  upsert: CardUpsertWithoutLayoutXSInput
  connect: CardWhereUniqueInput
}

input CardUpdateWithoutGroupingDataInput {
  cardType: CardType
  title: String
  layoutLG: LayoutLGUpdateOneRequiredWithoutCardInput
  layoutMD: LayoutMDUpdateOneRequiredWithoutCardInput
  layoutSM: LayoutSMUpdateOneRequiredWithoutCardInput
  layoutXS: LayoutXSUpdateOneRequiredWithoutCardInput
}

input CardUpdateWithoutLayoutLGDataInput {
  cardType: CardType
  title: String
  layoutMD: LayoutMDUpdateOneRequiredWithoutCardInput
  layoutSM: LayoutSMUpdateOneRequiredWithoutCardInput
  layoutXS: LayoutXSUpdateOneRequiredWithoutCardInput
  grouping: GroupingUpdateOneRequiredWithoutCardsInput
}

input CardUpdateWithoutLayoutMDDataInput {
  cardType: CardType
  title: String
  layoutLG: LayoutLGUpdateOneRequiredWithoutCardInput
  layoutSM: LayoutSMUpdateOneRequiredWithoutCardInput
  layoutXS: LayoutXSUpdateOneRequiredWithoutCardInput
  grouping: GroupingUpdateOneRequiredWithoutCardsInput
}

input CardUpdateWithoutLayoutSMDataInput {
  cardType: CardType
  title: String
  layoutLG: LayoutLGUpdateOneRequiredWithoutCardInput
  layoutMD: LayoutMDUpdateOneRequiredWithoutCardInput
  layoutXS: LayoutXSUpdateOneRequiredWithoutCardInput
  grouping: GroupingUpdateOneRequiredWithoutCardsInput
}

input CardUpdateWithoutLayoutXSDataInput {
  cardType: CardType
  title: String
  layoutLG: LayoutLGUpdateOneRequiredWithoutCardInput
  layoutMD: LayoutMDUpdateOneRequiredWithoutCardInput
  layoutSM: LayoutSMUpdateOneRequiredWithoutCardInput
  grouping: GroupingUpdateOneRequiredWithoutCardsInput
}

input CardUpdateWithWhereUniqueWithoutGroupingInput {
  where: CardWhereUniqueInput!
  data: CardUpdateWithoutGroupingDataInput!
}

input CardUpsertWithoutLayoutLGInput {
  update: CardUpdateWithoutLayoutLGDataInput!
  create: CardCreateWithoutLayoutLGInput!
}

input CardUpsertWithoutLayoutMDInput {
  update: CardUpdateWithoutLayoutMDDataInput!
  create: CardCreateWithoutLayoutMDInput!
}

input CardUpsertWithoutLayoutSMInput {
  update: CardUpdateWithoutLayoutSMDataInput!
  create: CardCreateWithoutLayoutSMInput!
}

input CardUpsertWithoutLayoutXSInput {
  update: CardUpdateWithoutLayoutXSDataInput!
  create: CardCreateWithoutLayoutXSInput!
}

input CardUpsertWithWhereUniqueWithoutGroupingInput {
  where: CardWhereUniqueInput!
  update: CardUpdateWithoutGroupingDataInput!
  create: CardCreateWithoutGroupingInput!
}

input CardWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  cardType: CardType
  cardType_not: CardType
  cardType_in: [CardType!]
  cardType_not_in: [CardType!]
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  layoutLG: LayoutLGWhereInput
  layoutMD: LayoutMDWhereInput
  layoutSM: LayoutSMWhereInput
  layoutXS: LayoutXSWhereInput
  grouping: GroupingWhereInput
  AND: [CardWhereInput!]
  OR: [CardWhereInput!]
  NOT: [CardWhereInput!]
}

input CardWhereUniqueInput {
  id: ID
}

type Dashboard {
  id: ID!
  name: String!
  groupings(where: GroupingWhereInput, orderBy: GroupingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Grouping!]
}

type DashboardConnection {
  pageInfo: PageInfo!
  edges: [DashboardEdge]!
  aggregate: AggregateDashboard!
}

input DashboardCreateInput {
  id: ID
  name: String!
  groupings: GroupingCreateManyWithoutDashboardInput
}

input DashboardCreateOneWithoutGroupingsInput {
  create: DashboardCreateWithoutGroupingsInput
  connect: DashboardWhereUniqueInput
}

input DashboardCreateWithoutGroupingsInput {
  id: ID
  name: String!
}

type DashboardEdge {
  node: Dashboard!
  cursor: String!
}

enum DashboardOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type DashboardPreviousValues {
  id: ID!
  name: String!
}

type DashboardSubscriptionPayload {
  mutation: MutationType!
  node: Dashboard
  updatedFields: [String!]
  previousValues: DashboardPreviousValues
}

input DashboardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DashboardWhereInput
  AND: [DashboardSubscriptionWhereInput!]
  OR: [DashboardSubscriptionWhereInput!]
  NOT: [DashboardSubscriptionWhereInput!]
}

input DashboardUpdateInput {
  name: String
  groupings: GroupingUpdateManyWithoutDashboardInput
}

input DashboardUpdateManyMutationInput {
  name: String
}

input DashboardUpdateOneRequiredWithoutGroupingsInput {
  create: DashboardCreateWithoutGroupingsInput
  update: DashboardUpdateWithoutGroupingsDataInput
  upsert: DashboardUpsertWithoutGroupingsInput
  connect: DashboardWhereUniqueInput
}

input DashboardUpdateWithoutGroupingsDataInput {
  name: String
}

input DashboardUpsertWithoutGroupingsInput {
  update: DashboardUpdateWithoutGroupingsDataInput!
  create: DashboardCreateWithoutGroupingsInput!
}

input DashboardWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  groupings_every: GroupingWhereInput
  groupings_some: GroupingWhereInput
  groupings_none: GroupingWhereInput
  AND: [DashboardWhereInput!]
  OR: [DashboardWhereInput!]
  NOT: [DashboardWhereInput!]
}

input DashboardWhereUniqueInput {
  id: ID
  name: String
}

type Day {
  id: ID!
  value: Int
  dayMonthYear: String!
  year: Year!
  quarter: Quarter!
  week: Week!
  month: Month!
  hours(where: HourWhereInput, orderBy: HourOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hour!]
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
}

type DayConnection {
  pageInfo: PageInfo!
  edges: [DayEdge]!
  aggregate: AggregateDay!
}

input DayCreateInput {
  id: ID
  value: Int
  dayMonthYear: String!
  year: YearCreateOneInput!
  quarter: QuarterCreateOneWithoutDaysInput!
  week: WeekCreateOneWithoutDaysInput!
  month: MonthCreateOneWithoutDaysInput!
  hours: HourCreateManyWithoutDayInput
  items: ItemCreateManyWithoutDayInput
}

input DayCreateManyWithoutMonthInput {
  create: [DayCreateWithoutMonthInput!]
  connect: [DayWhereUniqueInput!]
}

input DayCreateManyWithoutQuarterInput {
  create: [DayCreateWithoutQuarterInput!]
  connect: [DayWhereUniqueInput!]
}

input DayCreateManyWithoutWeekInput {
  create: [DayCreateWithoutWeekInput!]
  connect: [DayWhereUniqueInput!]
}

input DayCreateOneWithoutHoursInput {
  create: DayCreateWithoutHoursInput
  connect: DayWhereUniqueInput
}

input DayCreateOneWithoutItemsInput {
  create: DayCreateWithoutItemsInput
  connect: DayWhereUniqueInput
}

input DayCreateWithoutHoursInput {
  id: ID
  value: Int
  dayMonthYear: String!
  year: YearCreateOneInput!
  quarter: QuarterCreateOneWithoutDaysInput!
  week: WeekCreateOneWithoutDaysInput!
  month: MonthCreateOneWithoutDaysInput!
  items: ItemCreateManyWithoutDayInput
}

input DayCreateWithoutItemsInput {
  id: ID
  value: Int
  dayMonthYear: String!
  year: YearCreateOneInput!
  quarter: QuarterCreateOneWithoutDaysInput!
  week: WeekCreateOneWithoutDaysInput!
  month: MonthCreateOneWithoutDaysInput!
  hours: HourCreateManyWithoutDayInput
}

input DayCreateWithoutMonthInput {
  id: ID
  value: Int
  dayMonthYear: String!
  year: YearCreateOneInput!
  quarter: QuarterCreateOneWithoutDaysInput!
  week: WeekCreateOneWithoutDaysInput!
  hours: HourCreateManyWithoutDayInput
  items: ItemCreateManyWithoutDayInput
}

input DayCreateWithoutQuarterInput {
  id: ID
  value: Int
  dayMonthYear: String!
  year: YearCreateOneInput!
  week: WeekCreateOneWithoutDaysInput!
  month: MonthCreateOneWithoutDaysInput!
  hours: HourCreateManyWithoutDayInput
  items: ItemCreateManyWithoutDayInput
}

input DayCreateWithoutWeekInput {
  id: ID
  value: Int
  dayMonthYear: String!
  year: YearCreateOneInput!
  quarter: QuarterCreateOneWithoutDaysInput!
  month: MonthCreateOneWithoutDaysInput!
  hours: HourCreateManyWithoutDayInput
  items: ItemCreateManyWithoutDayInput
}

type DayEdge {
  node: Day!
  cursor: String!
}

enum DayOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  dayMonthYear_ASC
  dayMonthYear_DESC
}

type DayPreviousValues {
  id: ID!
  value: Int
  dayMonthYear: String!
}

input DayScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  dayMonthYear: String
  dayMonthYear_not: String
  dayMonthYear_in: [String!]
  dayMonthYear_not_in: [String!]
  dayMonthYear_lt: String
  dayMonthYear_lte: String
  dayMonthYear_gt: String
  dayMonthYear_gte: String
  dayMonthYear_contains: String
  dayMonthYear_not_contains: String
  dayMonthYear_starts_with: String
  dayMonthYear_not_starts_with: String
  dayMonthYear_ends_with: String
  dayMonthYear_not_ends_with: String
  AND: [DayScalarWhereInput!]
  OR: [DayScalarWhereInput!]
  NOT: [DayScalarWhereInput!]
}

type DaySubscriptionPayload {
  mutation: MutationType!
  node: Day
  updatedFields: [String!]
  previousValues: DayPreviousValues
}

input DaySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DayWhereInput
  AND: [DaySubscriptionWhereInput!]
  OR: [DaySubscriptionWhereInput!]
  NOT: [DaySubscriptionWhereInput!]
}

input DayUpdateInput {
  value: Int
  dayMonthYear: String
  year: YearUpdateOneRequiredInput
  quarter: QuarterUpdateOneRequiredWithoutDaysInput
  week: WeekUpdateOneRequiredWithoutDaysInput
  month: MonthUpdateOneRequiredWithoutDaysInput
  hours: HourUpdateManyWithoutDayInput
  items: ItemUpdateManyWithoutDayInput
}

input DayUpdateManyDataInput {
  value: Int
  dayMonthYear: String
}

input DayUpdateManyMutationInput {
  value: Int
  dayMonthYear: String
}

input DayUpdateManyWithoutMonthInput {
  create: [DayCreateWithoutMonthInput!]
  delete: [DayWhereUniqueInput!]
  connect: [DayWhereUniqueInput!]
  set: [DayWhereUniqueInput!]
  disconnect: [DayWhereUniqueInput!]
  update: [DayUpdateWithWhereUniqueWithoutMonthInput!]
  upsert: [DayUpsertWithWhereUniqueWithoutMonthInput!]
  deleteMany: [DayScalarWhereInput!]
  updateMany: [DayUpdateManyWithWhereNestedInput!]
}

input DayUpdateManyWithoutQuarterInput {
  create: [DayCreateWithoutQuarterInput!]
  delete: [DayWhereUniqueInput!]
  connect: [DayWhereUniqueInput!]
  set: [DayWhereUniqueInput!]
  disconnect: [DayWhereUniqueInput!]
  update: [DayUpdateWithWhereUniqueWithoutQuarterInput!]
  upsert: [DayUpsertWithWhereUniqueWithoutQuarterInput!]
  deleteMany: [DayScalarWhereInput!]
  updateMany: [DayUpdateManyWithWhereNestedInput!]
}

input DayUpdateManyWithoutWeekInput {
  create: [DayCreateWithoutWeekInput!]
  delete: [DayWhereUniqueInput!]
  connect: [DayWhereUniqueInput!]
  set: [DayWhereUniqueInput!]
  disconnect: [DayWhereUniqueInput!]
  update: [DayUpdateWithWhereUniqueWithoutWeekInput!]
  upsert: [DayUpsertWithWhereUniqueWithoutWeekInput!]
  deleteMany: [DayScalarWhereInput!]
  updateMany: [DayUpdateManyWithWhereNestedInput!]
}

input DayUpdateManyWithWhereNestedInput {
  where: DayScalarWhereInput!
  data: DayUpdateManyDataInput!
}

input DayUpdateOneRequiredWithoutHoursInput {
  create: DayCreateWithoutHoursInput
  update: DayUpdateWithoutHoursDataInput
  upsert: DayUpsertWithoutHoursInput
  connect: DayWhereUniqueInput
}

input DayUpdateOneRequiredWithoutItemsInput {
  create: DayCreateWithoutItemsInput
  update: DayUpdateWithoutItemsDataInput
  upsert: DayUpsertWithoutItemsInput
  connect: DayWhereUniqueInput
}

input DayUpdateWithoutHoursDataInput {
  value: Int
  dayMonthYear: String
  year: YearUpdateOneRequiredInput
  quarter: QuarterUpdateOneRequiredWithoutDaysInput
  week: WeekUpdateOneRequiredWithoutDaysInput
  month: MonthUpdateOneRequiredWithoutDaysInput
  items: ItemUpdateManyWithoutDayInput
}

input DayUpdateWithoutItemsDataInput {
  value: Int
  dayMonthYear: String
  year: YearUpdateOneRequiredInput
  quarter: QuarterUpdateOneRequiredWithoutDaysInput
  week: WeekUpdateOneRequiredWithoutDaysInput
  month: MonthUpdateOneRequiredWithoutDaysInput
  hours: HourUpdateManyWithoutDayInput
}

input DayUpdateWithoutMonthDataInput {
  value: Int
  dayMonthYear: String
  year: YearUpdateOneRequiredInput
  quarter: QuarterUpdateOneRequiredWithoutDaysInput
  week: WeekUpdateOneRequiredWithoutDaysInput
  hours: HourUpdateManyWithoutDayInput
  items: ItemUpdateManyWithoutDayInput
}

input DayUpdateWithoutQuarterDataInput {
  value: Int
  dayMonthYear: String
  year: YearUpdateOneRequiredInput
  week: WeekUpdateOneRequiredWithoutDaysInput
  month: MonthUpdateOneRequiredWithoutDaysInput
  hours: HourUpdateManyWithoutDayInput
  items: ItemUpdateManyWithoutDayInput
}

input DayUpdateWithoutWeekDataInput {
  value: Int
  dayMonthYear: String
  year: YearUpdateOneRequiredInput
  quarter: QuarterUpdateOneRequiredWithoutDaysInput
  month: MonthUpdateOneRequiredWithoutDaysInput
  hours: HourUpdateManyWithoutDayInput
  items: ItemUpdateManyWithoutDayInput
}

input DayUpdateWithWhereUniqueWithoutMonthInput {
  where: DayWhereUniqueInput!
  data: DayUpdateWithoutMonthDataInput!
}

input DayUpdateWithWhereUniqueWithoutQuarterInput {
  where: DayWhereUniqueInput!
  data: DayUpdateWithoutQuarterDataInput!
}

input DayUpdateWithWhereUniqueWithoutWeekInput {
  where: DayWhereUniqueInput!
  data: DayUpdateWithoutWeekDataInput!
}

input DayUpsertWithoutHoursInput {
  update: DayUpdateWithoutHoursDataInput!
  create: DayCreateWithoutHoursInput!
}

input DayUpsertWithoutItemsInput {
  update: DayUpdateWithoutItemsDataInput!
  create: DayCreateWithoutItemsInput!
}

input DayUpsertWithWhereUniqueWithoutMonthInput {
  where: DayWhereUniqueInput!
  update: DayUpdateWithoutMonthDataInput!
  create: DayCreateWithoutMonthInput!
}

input DayUpsertWithWhereUniqueWithoutQuarterInput {
  where: DayWhereUniqueInput!
  update: DayUpdateWithoutQuarterDataInput!
  create: DayCreateWithoutQuarterInput!
}

input DayUpsertWithWhereUniqueWithoutWeekInput {
  where: DayWhereUniqueInput!
  update: DayUpdateWithoutWeekDataInput!
  create: DayCreateWithoutWeekInput!
}

input DayWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  dayMonthYear: String
  dayMonthYear_not: String
  dayMonthYear_in: [String!]
  dayMonthYear_not_in: [String!]
  dayMonthYear_lt: String
  dayMonthYear_lte: String
  dayMonthYear_gt: String
  dayMonthYear_gte: String
  dayMonthYear_contains: String
  dayMonthYear_not_contains: String
  dayMonthYear_starts_with: String
  dayMonthYear_not_starts_with: String
  dayMonthYear_ends_with: String
  dayMonthYear_not_ends_with: String
  year: YearWhereInput
  quarter: QuarterWhereInput
  week: WeekWhereInput
  month: MonthWhereInput
  hours_every: HourWhereInput
  hours_some: HourWhereInput
  hours_none: HourWhereInput
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  AND: [DayWhereInput!]
  OR: [DayWhereInput!]
  NOT: [DayWhereInput!]
}

input DayWhereUniqueInput {
  id: ID
  dayMonthYear: String
}

type Entity {
  id: ID!
  entityID: String
  name: String
  linkForEntity: String
  type: EntityType
  source: Source!
  parent: Entity
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]!
  aggregate: AggregateEntity!
}

input EntityCreateInput {
  id: ID
  entityID: String
  name: String
  linkForEntity: String
  type: EntityType
  source: Source!
  parent: EntityCreateOneWithoutParentInput
  items: ItemCreateManyWithoutTriggerInput
}

input EntityCreateOneWithoutItemsInput {
  create: EntityCreateWithoutItemsInput
  connect: EntityWhereUniqueInput
}

input EntityCreateOneWithoutParentInput {
  create: EntityCreateWithoutParentInput
  connect: EntityWhereUniqueInput
}

input EntityCreateWithoutItemsInput {
  id: ID
  entityID: String
  name: String
  linkForEntity: String
  type: EntityType
  source: Source!
  parent: EntityCreateOneWithoutParentInput
}

input EntityCreateWithoutParentInput {
  id: ID
  entityID: String
  name: String
  linkForEntity: String
  type: EntityType
  source: Source!
  items: ItemCreateManyWithoutTriggerInput
}

type EntityEdge {
  node: Entity!
  cursor: String!
}

enum EntityOrderByInput {
  id_ASC
  id_DESC
  entityID_ASC
  entityID_DESC
  name_ASC
  name_DESC
  linkForEntity_ASC
  linkForEntity_DESC
  type_ASC
  type_DESC
  source_ASC
  source_DESC
}

type EntityPreviousValues {
  id: ID!
  entityID: String
  name: String
  linkForEntity: String
  type: EntityType
  source: Source!
}

type EntitySubscriptionPayload {
  mutation: MutationType!
  node: Entity
  updatedFields: [String!]
  previousValues: EntityPreviousValues
}

input EntitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EntityWhereInput
  AND: [EntitySubscriptionWhereInput!]
  OR: [EntitySubscriptionWhereInput!]
  NOT: [EntitySubscriptionWhereInput!]
}

enum EntityType {
  NODE
  INTERFACE
}

input EntityUpdateInput {
  entityID: String
  name: String
  linkForEntity: String
  type: EntityType
  source: Source
  parent: EntityUpdateOneWithoutParentInput
  items: ItemUpdateManyWithoutTriggerInput
}

input EntityUpdateManyMutationInput {
  entityID: String
  name: String
  linkForEntity: String
  type: EntityType
  source: Source
}

input EntityUpdateOneRequiredWithoutItemsInput {
  create: EntityCreateWithoutItemsInput
  update: EntityUpdateWithoutItemsDataInput
  upsert: EntityUpsertWithoutItemsInput
  connect: EntityWhereUniqueInput
}

input EntityUpdateOneWithoutParentInput {
  create: EntityCreateWithoutParentInput
  update: EntityUpdateWithoutParentDataInput
  upsert: EntityUpsertWithoutParentInput
  delete: Boolean
  disconnect: Boolean
  connect: EntityWhereUniqueInput
}

input EntityUpdateWithoutItemsDataInput {
  entityID: String
  name: String
  linkForEntity: String
  type: EntityType
  source: Source
  parent: EntityUpdateOneWithoutParentInput
}

input EntityUpdateWithoutParentDataInput {
  entityID: String
  name: String
  linkForEntity: String
  type: EntityType
  source: Source
  items: ItemUpdateManyWithoutTriggerInput
}

input EntityUpsertWithoutItemsInput {
  update: EntityUpdateWithoutItemsDataInput!
  create: EntityCreateWithoutItemsInput!
}

input EntityUpsertWithoutParentInput {
  update: EntityUpdateWithoutParentDataInput!
  create: EntityCreateWithoutParentInput!
}

input EntityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  entityID: String
  entityID_not: String
  entityID_in: [String!]
  entityID_not_in: [String!]
  entityID_lt: String
  entityID_lte: String
  entityID_gt: String
  entityID_gte: String
  entityID_contains: String
  entityID_not_contains: String
  entityID_starts_with: String
  entityID_not_starts_with: String
  entityID_ends_with: String
  entityID_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  linkForEntity: String
  linkForEntity_not: String
  linkForEntity_in: [String!]
  linkForEntity_not_in: [String!]
  linkForEntity_lt: String
  linkForEntity_lte: String
  linkForEntity_gt: String
  linkForEntity_gte: String
  linkForEntity_contains: String
  linkForEntity_not_contains: String
  linkForEntity_starts_with: String
  linkForEntity_not_starts_with: String
  linkForEntity_ends_with: String
  linkForEntity_not_ends_with: String
  type: EntityType
  type_not: EntityType
  type_in: [EntityType!]
  type_not_in: [EntityType!]
  source: Source
  source_not: Source
  source_in: [Source!]
  source_not_in: [Source!]
  parent: EntityWhereInput
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  AND: [EntityWhereInput!]
  OR: [EntityWhereInput!]
  NOT: [EntityWhereInput!]
}

input EntityWhereUniqueInput {
  id: ID
  entityID: String
  name: String
}

type Grouping {
  id: ID!
  title: String
  subtitle: String
  dashboard: Dashboard!
  chips: [String!]!
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card!]
  layoutLGs(where: LayoutLGWhereInput, orderBy: LayoutLGOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LayoutLG!]
  layoutMDs(where: LayoutMDWhereInput, orderBy: LayoutMDOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LayoutMD!]
  layoutSMs(where: LayoutSMWhereInput, orderBy: LayoutSMOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LayoutSM!]
  layoutXSs(where: LayoutXSWhereInput, orderBy: LayoutXSOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LayoutXS!]
}

type GroupingConnection {
  pageInfo: PageInfo!
  edges: [GroupingEdge]!
  aggregate: AggregateGrouping!
}

input GroupingCreatechipsInput {
  set: [String!]
}

input GroupingCreateInput {
  id: ID
  title: String
  subtitle: String
  dashboard: DashboardCreateOneWithoutGroupingsInput!
  chips: GroupingCreatechipsInput
  cards: CardCreateManyWithoutGroupingInput
  layoutLGs: LayoutLGCreateManyWithoutGroupingInput
  layoutMDs: LayoutMDCreateManyWithoutGroupingInput
  layoutSMs: LayoutSMCreateManyWithoutGroupingInput
  layoutXSs: LayoutXSCreateManyWithoutGroupingInput
}

input GroupingCreateManyWithoutDashboardInput {
  create: [GroupingCreateWithoutDashboardInput!]
  connect: [GroupingWhereUniqueInput!]
}

input GroupingCreateOneWithoutCardsInput {
  create: GroupingCreateWithoutCardsInput
  connect: GroupingWhereUniqueInput
}

input GroupingCreateOneWithoutLayoutLGsInput {
  create: GroupingCreateWithoutLayoutLGsInput
  connect: GroupingWhereUniqueInput
}

input GroupingCreateOneWithoutLayoutMDsInput {
  create: GroupingCreateWithoutLayoutMDsInput
  connect: GroupingWhereUniqueInput
}

input GroupingCreateOneWithoutLayoutSMsInput {
  create: GroupingCreateWithoutLayoutSMsInput
  connect: GroupingWhereUniqueInput
}

input GroupingCreateOneWithoutLayoutXSsInput {
  create: GroupingCreateWithoutLayoutXSsInput
  connect: GroupingWhereUniqueInput
}

input GroupingCreateWithoutCardsInput {
  id: ID
  title: String
  subtitle: String
  dashboard: DashboardCreateOneWithoutGroupingsInput!
  chips: GroupingCreatechipsInput
  layoutLGs: LayoutLGCreateManyWithoutGroupingInput
  layoutMDs: LayoutMDCreateManyWithoutGroupingInput
  layoutSMs: LayoutSMCreateManyWithoutGroupingInput
  layoutXSs: LayoutXSCreateManyWithoutGroupingInput
}

input GroupingCreateWithoutDashboardInput {
  id: ID
  title: String
  subtitle: String
  chips: GroupingCreatechipsInput
  cards: CardCreateManyWithoutGroupingInput
  layoutLGs: LayoutLGCreateManyWithoutGroupingInput
  layoutMDs: LayoutMDCreateManyWithoutGroupingInput
  layoutSMs: LayoutSMCreateManyWithoutGroupingInput
  layoutXSs: LayoutXSCreateManyWithoutGroupingInput
}

input GroupingCreateWithoutLayoutLGsInput {
  id: ID
  title: String
  subtitle: String
  dashboard: DashboardCreateOneWithoutGroupingsInput!
  chips: GroupingCreatechipsInput
  cards: CardCreateManyWithoutGroupingInput
  layoutMDs: LayoutMDCreateManyWithoutGroupingInput
  layoutSMs: LayoutSMCreateManyWithoutGroupingInput
  layoutXSs: LayoutXSCreateManyWithoutGroupingInput
}

input GroupingCreateWithoutLayoutMDsInput {
  id: ID
  title: String
  subtitle: String
  dashboard: DashboardCreateOneWithoutGroupingsInput!
  chips: GroupingCreatechipsInput
  cards: CardCreateManyWithoutGroupingInput
  layoutLGs: LayoutLGCreateManyWithoutGroupingInput
  layoutSMs: LayoutSMCreateManyWithoutGroupingInput
  layoutXSs: LayoutXSCreateManyWithoutGroupingInput
}

input GroupingCreateWithoutLayoutSMsInput {
  id: ID
  title: String
  subtitle: String
  dashboard: DashboardCreateOneWithoutGroupingsInput!
  chips: GroupingCreatechipsInput
  cards: CardCreateManyWithoutGroupingInput
  layoutLGs: LayoutLGCreateManyWithoutGroupingInput
  layoutMDs: LayoutMDCreateManyWithoutGroupingInput
  layoutXSs: LayoutXSCreateManyWithoutGroupingInput
}

input GroupingCreateWithoutLayoutXSsInput {
  id: ID
  title: String
  subtitle: String
  dashboard: DashboardCreateOneWithoutGroupingsInput!
  chips: GroupingCreatechipsInput
  cards: CardCreateManyWithoutGroupingInput
  layoutLGs: LayoutLGCreateManyWithoutGroupingInput
  layoutMDs: LayoutMDCreateManyWithoutGroupingInput
  layoutSMs: LayoutSMCreateManyWithoutGroupingInput
}

type GroupingEdge {
  node: Grouping!
  cursor: String!
}

enum GroupingOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  subtitle_ASC
  subtitle_DESC
}

type GroupingPreviousValues {
  id: ID!
  title: String
  subtitle: String
  chips: [String!]!
}

input GroupingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  subtitle: String
  subtitle_not: String
  subtitle_in: [String!]
  subtitle_not_in: [String!]
  subtitle_lt: String
  subtitle_lte: String
  subtitle_gt: String
  subtitle_gte: String
  subtitle_contains: String
  subtitle_not_contains: String
  subtitle_starts_with: String
  subtitle_not_starts_with: String
  subtitle_ends_with: String
  subtitle_not_ends_with: String
  AND: [GroupingScalarWhereInput!]
  OR: [GroupingScalarWhereInput!]
  NOT: [GroupingScalarWhereInput!]
}

type GroupingSubscriptionPayload {
  mutation: MutationType!
  node: Grouping
  updatedFields: [String!]
  previousValues: GroupingPreviousValues
}

input GroupingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupingWhereInput
  AND: [GroupingSubscriptionWhereInput!]
  OR: [GroupingSubscriptionWhereInput!]
  NOT: [GroupingSubscriptionWhereInput!]
}

input GroupingUpdatechipsInput {
  set: [String!]
}

input GroupingUpdateInput {
  title: String
  subtitle: String
  dashboard: DashboardUpdateOneRequiredWithoutGroupingsInput
  chips: GroupingUpdatechipsInput
  cards: CardUpdateManyWithoutGroupingInput
  layoutLGs: LayoutLGUpdateManyWithoutGroupingInput
  layoutMDs: LayoutMDUpdateManyWithoutGroupingInput
  layoutSMs: LayoutSMUpdateManyWithoutGroupingInput
  layoutXSs: LayoutXSUpdateManyWithoutGroupingInput
}

input GroupingUpdateManyDataInput {
  title: String
  subtitle: String
  chips: GroupingUpdatechipsInput
}

input GroupingUpdateManyMutationInput {
  title: String
  subtitle: String
  chips: GroupingUpdatechipsInput
}

input GroupingUpdateManyWithoutDashboardInput {
  create: [GroupingCreateWithoutDashboardInput!]
  delete: [GroupingWhereUniqueInput!]
  connect: [GroupingWhereUniqueInput!]
  set: [GroupingWhereUniqueInput!]
  disconnect: [GroupingWhereUniqueInput!]
  update: [GroupingUpdateWithWhereUniqueWithoutDashboardInput!]
  upsert: [GroupingUpsertWithWhereUniqueWithoutDashboardInput!]
  deleteMany: [GroupingScalarWhereInput!]
  updateMany: [GroupingUpdateManyWithWhereNestedInput!]
}

input GroupingUpdateManyWithWhereNestedInput {
  where: GroupingScalarWhereInput!
  data: GroupingUpdateManyDataInput!
}

input GroupingUpdateOneRequiredWithoutCardsInput {
  create: GroupingCreateWithoutCardsInput
  update: GroupingUpdateWithoutCardsDataInput
  upsert: GroupingUpsertWithoutCardsInput
  connect: GroupingWhereUniqueInput
}

input GroupingUpdateOneRequiredWithoutLayoutLGsInput {
  create: GroupingCreateWithoutLayoutLGsInput
  update: GroupingUpdateWithoutLayoutLGsDataInput
  upsert: GroupingUpsertWithoutLayoutLGsInput
  connect: GroupingWhereUniqueInput
}

input GroupingUpdateOneRequiredWithoutLayoutMDsInput {
  create: GroupingCreateWithoutLayoutMDsInput
  update: GroupingUpdateWithoutLayoutMDsDataInput
  upsert: GroupingUpsertWithoutLayoutMDsInput
  connect: GroupingWhereUniqueInput
}

input GroupingUpdateOneRequiredWithoutLayoutSMsInput {
  create: GroupingCreateWithoutLayoutSMsInput
  update: GroupingUpdateWithoutLayoutSMsDataInput
  upsert: GroupingUpsertWithoutLayoutSMsInput
  connect: GroupingWhereUniqueInput
}

input GroupingUpdateOneRequiredWithoutLayoutXSsInput {
  create: GroupingCreateWithoutLayoutXSsInput
  update: GroupingUpdateWithoutLayoutXSsDataInput
  upsert: GroupingUpsertWithoutLayoutXSsInput
  connect: GroupingWhereUniqueInput
}

input GroupingUpdateWithoutCardsDataInput {
  title: String
  subtitle: String
  dashboard: DashboardUpdateOneRequiredWithoutGroupingsInput
  chips: GroupingUpdatechipsInput
  layoutLGs: LayoutLGUpdateManyWithoutGroupingInput
  layoutMDs: LayoutMDUpdateManyWithoutGroupingInput
  layoutSMs: LayoutSMUpdateManyWithoutGroupingInput
  layoutXSs: LayoutXSUpdateManyWithoutGroupingInput
}

input GroupingUpdateWithoutDashboardDataInput {
  title: String
  subtitle: String
  chips: GroupingUpdatechipsInput
  cards: CardUpdateManyWithoutGroupingInput
  layoutLGs: LayoutLGUpdateManyWithoutGroupingInput
  layoutMDs: LayoutMDUpdateManyWithoutGroupingInput
  layoutSMs: LayoutSMUpdateManyWithoutGroupingInput
  layoutXSs: LayoutXSUpdateManyWithoutGroupingInput
}

input GroupingUpdateWithoutLayoutLGsDataInput {
  title: String
  subtitle: String
  dashboard: DashboardUpdateOneRequiredWithoutGroupingsInput
  chips: GroupingUpdatechipsInput
  cards: CardUpdateManyWithoutGroupingInput
  layoutMDs: LayoutMDUpdateManyWithoutGroupingInput
  layoutSMs: LayoutSMUpdateManyWithoutGroupingInput
  layoutXSs: LayoutXSUpdateManyWithoutGroupingInput
}

input GroupingUpdateWithoutLayoutMDsDataInput {
  title: String
  subtitle: String
  dashboard: DashboardUpdateOneRequiredWithoutGroupingsInput
  chips: GroupingUpdatechipsInput
  cards: CardUpdateManyWithoutGroupingInput
  layoutLGs: LayoutLGUpdateManyWithoutGroupingInput
  layoutSMs: LayoutSMUpdateManyWithoutGroupingInput
  layoutXSs: LayoutXSUpdateManyWithoutGroupingInput
}

input GroupingUpdateWithoutLayoutSMsDataInput {
  title: String
  subtitle: String
  dashboard: DashboardUpdateOneRequiredWithoutGroupingsInput
  chips: GroupingUpdatechipsInput
  cards: CardUpdateManyWithoutGroupingInput
  layoutLGs: LayoutLGUpdateManyWithoutGroupingInput
  layoutMDs: LayoutMDUpdateManyWithoutGroupingInput
  layoutXSs: LayoutXSUpdateManyWithoutGroupingInput
}

input GroupingUpdateWithoutLayoutXSsDataInput {
  title: String
  subtitle: String
  dashboard: DashboardUpdateOneRequiredWithoutGroupingsInput
  chips: GroupingUpdatechipsInput
  cards: CardUpdateManyWithoutGroupingInput
  layoutLGs: LayoutLGUpdateManyWithoutGroupingInput
  layoutMDs: LayoutMDUpdateManyWithoutGroupingInput
  layoutSMs: LayoutSMUpdateManyWithoutGroupingInput
}

input GroupingUpdateWithWhereUniqueWithoutDashboardInput {
  where: GroupingWhereUniqueInput!
  data: GroupingUpdateWithoutDashboardDataInput!
}

input GroupingUpsertWithoutCardsInput {
  update: GroupingUpdateWithoutCardsDataInput!
  create: GroupingCreateWithoutCardsInput!
}

input GroupingUpsertWithoutLayoutLGsInput {
  update: GroupingUpdateWithoutLayoutLGsDataInput!
  create: GroupingCreateWithoutLayoutLGsInput!
}

input GroupingUpsertWithoutLayoutMDsInput {
  update: GroupingUpdateWithoutLayoutMDsDataInput!
  create: GroupingCreateWithoutLayoutMDsInput!
}

input GroupingUpsertWithoutLayoutSMsInput {
  update: GroupingUpdateWithoutLayoutSMsDataInput!
  create: GroupingCreateWithoutLayoutSMsInput!
}

input GroupingUpsertWithoutLayoutXSsInput {
  update: GroupingUpdateWithoutLayoutXSsDataInput!
  create: GroupingCreateWithoutLayoutXSsInput!
}

input GroupingUpsertWithWhereUniqueWithoutDashboardInput {
  where: GroupingWhereUniqueInput!
  update: GroupingUpdateWithoutDashboardDataInput!
  create: GroupingCreateWithoutDashboardInput!
}

input GroupingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  subtitle: String
  subtitle_not: String
  subtitle_in: [String!]
  subtitle_not_in: [String!]
  subtitle_lt: String
  subtitle_lte: String
  subtitle_gt: String
  subtitle_gte: String
  subtitle_contains: String
  subtitle_not_contains: String
  subtitle_starts_with: String
  subtitle_not_starts_with: String
  subtitle_ends_with: String
  subtitle_not_ends_with: String
  dashboard: DashboardWhereInput
  cards_every: CardWhereInput
  cards_some: CardWhereInput
  cards_none: CardWhereInput
  layoutLGs_every: LayoutLGWhereInput
  layoutLGs_some: LayoutLGWhereInput
  layoutLGs_none: LayoutLGWhereInput
  layoutMDs_every: LayoutMDWhereInput
  layoutMDs_some: LayoutMDWhereInput
  layoutMDs_none: LayoutMDWhereInput
  layoutSMs_every: LayoutSMWhereInput
  layoutSMs_some: LayoutSMWhereInput
  layoutSMs_none: LayoutSMWhereInput
  layoutXSs_every: LayoutXSWhereInput
  layoutXSs_some: LayoutXSWhereInput
  layoutXSs_none: LayoutXSWhereInput
  AND: [GroupingWhereInput!]
  OR: [GroupingWhereInput!]
  NOT: [GroupingWhereInput!]
}

input GroupingWhereUniqueInput {
  id: ID
}

type Hour {
  id: ID!
  value: Int!
  hourDayMonthYear: String!
  day: Day!
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
}

type HourConnection {
  pageInfo: PageInfo!
  edges: [HourEdge]!
  aggregate: AggregateHour!
}

input HourCreateInput {
  id: ID
  value: Int!
  hourDayMonthYear: String!
  day: DayCreateOneWithoutHoursInput!
  items: ItemCreateManyWithoutHourInput
}

input HourCreateManyWithoutDayInput {
  create: [HourCreateWithoutDayInput!]
  connect: [HourWhereUniqueInput!]
}

input HourCreateOneWithoutItemsInput {
  create: HourCreateWithoutItemsInput
  connect: HourWhereUniqueInput
}

input HourCreateWithoutDayInput {
  id: ID
  value: Int!
  hourDayMonthYear: String!
  items: ItemCreateManyWithoutHourInput
}

input HourCreateWithoutItemsInput {
  id: ID
  value: Int!
  hourDayMonthYear: String!
  day: DayCreateOneWithoutHoursInput!
}

type HourEdge {
  node: Hour!
  cursor: String!
}

enum HourOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  hourDayMonthYear_ASC
  hourDayMonthYear_DESC
}

type HourPreviousValues {
  id: ID!
  value: Int!
  hourDayMonthYear: String!
}

input HourScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  hourDayMonthYear: String
  hourDayMonthYear_not: String
  hourDayMonthYear_in: [String!]
  hourDayMonthYear_not_in: [String!]
  hourDayMonthYear_lt: String
  hourDayMonthYear_lte: String
  hourDayMonthYear_gt: String
  hourDayMonthYear_gte: String
  hourDayMonthYear_contains: String
  hourDayMonthYear_not_contains: String
  hourDayMonthYear_starts_with: String
  hourDayMonthYear_not_starts_with: String
  hourDayMonthYear_ends_with: String
  hourDayMonthYear_not_ends_with: String
  AND: [HourScalarWhereInput!]
  OR: [HourScalarWhereInput!]
  NOT: [HourScalarWhereInput!]
}

type HourSubscriptionPayload {
  mutation: MutationType!
  node: Hour
  updatedFields: [String!]
  previousValues: HourPreviousValues
}

input HourSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HourWhereInput
  AND: [HourSubscriptionWhereInput!]
  OR: [HourSubscriptionWhereInput!]
  NOT: [HourSubscriptionWhereInput!]
}

input HourUpdateInput {
  value: Int
  hourDayMonthYear: String
  day: DayUpdateOneRequiredWithoutHoursInput
  items: ItemUpdateManyWithoutHourInput
}

input HourUpdateManyDataInput {
  value: Int
  hourDayMonthYear: String
}

input HourUpdateManyMutationInput {
  value: Int
  hourDayMonthYear: String
}

input HourUpdateManyWithoutDayInput {
  create: [HourCreateWithoutDayInput!]
  delete: [HourWhereUniqueInput!]
  connect: [HourWhereUniqueInput!]
  set: [HourWhereUniqueInput!]
  disconnect: [HourWhereUniqueInput!]
  update: [HourUpdateWithWhereUniqueWithoutDayInput!]
  upsert: [HourUpsertWithWhereUniqueWithoutDayInput!]
  deleteMany: [HourScalarWhereInput!]
  updateMany: [HourUpdateManyWithWhereNestedInput!]
}

input HourUpdateManyWithWhereNestedInput {
  where: HourScalarWhereInput!
  data: HourUpdateManyDataInput!
}

input HourUpdateOneRequiredWithoutItemsInput {
  create: HourCreateWithoutItemsInput
  update: HourUpdateWithoutItemsDataInput
  upsert: HourUpsertWithoutItemsInput
  connect: HourWhereUniqueInput
}

input HourUpdateWithoutDayDataInput {
  value: Int
  hourDayMonthYear: String
  items: ItemUpdateManyWithoutHourInput
}

input HourUpdateWithoutItemsDataInput {
  value: Int
  hourDayMonthYear: String
  day: DayUpdateOneRequiredWithoutHoursInput
}

input HourUpdateWithWhereUniqueWithoutDayInput {
  where: HourWhereUniqueInput!
  data: HourUpdateWithoutDayDataInput!
}

input HourUpsertWithoutItemsInput {
  update: HourUpdateWithoutItemsDataInput!
  create: HourCreateWithoutItemsInput!
}

input HourUpsertWithWhereUniqueWithoutDayInput {
  where: HourWhereUniqueInput!
  update: HourUpdateWithoutDayDataInput!
  create: HourCreateWithoutDayInput!
}

input HourWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  hourDayMonthYear: String
  hourDayMonthYear_not: String
  hourDayMonthYear_in: [String!]
  hourDayMonthYear_not_in: [String!]
  hourDayMonthYear_lt: String
  hourDayMonthYear_lte: String
  hourDayMonthYear_gt: String
  hourDayMonthYear_gte: String
  hourDayMonthYear_contains: String
  hourDayMonthYear_not_contains: String
  hourDayMonthYear_starts_with: String
  hourDayMonthYear_not_starts_with: String
  hourDayMonthYear_ends_with: String
  hourDayMonthYear_not_ends_with: String
  day: DayWhereInput
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  AND: [HourWhereInput!]
  OR: [HourWhereInput!]
  NOT: [HourWhereInput!]
}

input HourWhereUniqueInput {
  id: ID
  hourDayMonthYear: String
}

type Item {
  id: ID!
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String!
  name: String
  message: String
  level: Level
  source: Source
  trigger: Entity!
  hour: Hour!
  day: Day!
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  id: ID
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String!
  name: String
  message: String
  level: Level
  source: Source
  trigger: EntityCreateOneWithoutItemsInput!
  hour: HourCreateOneWithoutItemsInput!
  day: DayCreateOneWithoutItemsInput!
}

input ItemCreateManyWithoutDayInput {
  create: [ItemCreateWithoutDayInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateManyWithoutHourInput {
  create: [ItemCreateWithoutHourInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateManyWithoutTriggerInput {
  create: [ItemCreateWithoutTriggerInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateWithoutDayInput {
  id: ID
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String!
  name: String
  message: String
  level: Level
  source: Source
  trigger: EntityCreateOneWithoutItemsInput!
  hour: HourCreateOneWithoutItemsInput!
}

input ItemCreateWithoutHourInput {
  id: ID
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String!
  name: String
  message: String
  level: Level
  source: Source
  trigger: EntityCreateOneWithoutItemsInput!
  day: DayCreateOneWithoutItemsInput!
}

input ItemCreateWithoutTriggerInput {
  id: ID
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String!
  name: String
  message: String
  level: Level
  source: Source
  hour: HourCreateOneWithoutItemsInput!
  day: DayCreateOneWithoutItemsInput!
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  alertID_ASC
  alertID_DESC
  logID_ASC
  logID_DESC
  triggerTime_ASC
  triggerTime_DESC
  name_ASC
  name_DESC
  message_ASC
  message_DESC
  level_ASC
  level_DESC
  source_ASC
  source_DESC
}

type ItemPreviousValues {
  id: ID!
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String!
  name: String
  message: String
  level: Level
  source: Source
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: ItemType
  type_not: ItemType
  type_in: [ItemType!]
  type_not_in: [ItemType!]
  alertID: Int
  alertID_not: Int
  alertID_in: [Int!]
  alertID_not_in: [Int!]
  alertID_lt: Int
  alertID_lte: Int
  alertID_gt: Int
  alertID_gte: Int
  logID: String
  logID_not: String
  logID_in: [String!]
  logID_not_in: [String!]
  logID_lt: String
  logID_lte: String
  logID_gt: String
  logID_gte: String
  logID_contains: String
  logID_not_contains: String
  logID_starts_with: String
  logID_not_starts_with: String
  logID_ends_with: String
  logID_not_ends_with: String
  triggerTime: String
  triggerTime_not: String
  triggerTime_in: [String!]
  triggerTime_not_in: [String!]
  triggerTime_lt: String
  triggerTime_lte: String
  triggerTime_gt: String
  triggerTime_gte: String
  triggerTime_contains: String
  triggerTime_not_contains: String
  triggerTime_starts_with: String
  triggerTime_not_starts_with: String
  triggerTime_ends_with: String
  triggerTime_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  level: Level
  level_not: Level
  level_in: [Level!]
  level_not_in: [Level!]
  source: Source
  source_not: Source
  source_in: [Source!]
  source_not_in: [Source!]
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

enum ItemType {
  ALERT
  TRAP
  SYSLOG
  WINDOWSEVENT
  VMWAREEVENT
  UNKNOWN
}

input ItemUpdateInput {
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String
  name: String
  message: String
  level: Level
  source: Source
  trigger: EntityUpdateOneRequiredWithoutItemsInput
  hour: HourUpdateOneRequiredWithoutItemsInput
  day: DayUpdateOneRequiredWithoutItemsInput
}

input ItemUpdateManyDataInput {
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String
  name: String
  message: String
  level: Level
  source: Source
}

input ItemUpdateManyMutationInput {
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String
  name: String
  message: String
  level: Level
  source: Source
}

input ItemUpdateManyWithoutDayInput {
  create: [ItemCreateWithoutDayInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutDayInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutDayInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithoutHourInput {
  create: [ItemCreateWithoutHourInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutHourInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutHourInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithoutTriggerInput {
  create: [ItemCreateWithoutTriggerInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutTriggerInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutTriggerInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdateWithoutDayDataInput {
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String
  name: String
  message: String
  level: Level
  source: Source
  trigger: EntityUpdateOneRequiredWithoutItemsInput
  hour: HourUpdateOneRequiredWithoutItemsInput
}

input ItemUpdateWithoutHourDataInput {
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String
  name: String
  message: String
  level: Level
  source: Source
  trigger: EntityUpdateOneRequiredWithoutItemsInput
  day: DayUpdateOneRequiredWithoutItemsInput
}

input ItemUpdateWithoutTriggerDataInput {
  type: ItemType
  alertID: Int
  logID: String
  triggerTime: String
  name: String
  message: String
  level: Level
  source: Source
  hour: HourUpdateOneRequiredWithoutItemsInput
  day: DayUpdateOneRequiredWithoutItemsInput
}

input ItemUpdateWithWhereUniqueWithoutDayInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutDayDataInput!
}

input ItemUpdateWithWhereUniqueWithoutHourInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutHourDataInput!
}

input ItemUpdateWithWhereUniqueWithoutTriggerInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutTriggerDataInput!
}

input ItemUpsertWithWhereUniqueWithoutDayInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutDayDataInput!
  create: ItemCreateWithoutDayInput!
}

input ItemUpsertWithWhereUniqueWithoutHourInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutHourDataInput!
  create: ItemCreateWithoutHourInput!
}

input ItemUpsertWithWhereUniqueWithoutTriggerInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutTriggerDataInput!
  create: ItemCreateWithoutTriggerInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: ItemType
  type_not: ItemType
  type_in: [ItemType!]
  type_not_in: [ItemType!]
  alertID: Int
  alertID_not: Int
  alertID_in: [Int!]
  alertID_not_in: [Int!]
  alertID_lt: Int
  alertID_lte: Int
  alertID_gt: Int
  alertID_gte: Int
  logID: String
  logID_not: String
  logID_in: [String!]
  logID_not_in: [String!]
  logID_lt: String
  logID_lte: String
  logID_gt: String
  logID_gte: String
  logID_contains: String
  logID_not_contains: String
  logID_starts_with: String
  logID_not_starts_with: String
  logID_ends_with: String
  logID_not_ends_with: String
  triggerTime: String
  triggerTime_not: String
  triggerTime_in: [String!]
  triggerTime_not_in: [String!]
  triggerTime_lt: String
  triggerTime_lte: String
  triggerTime_gt: String
  triggerTime_gte: String
  triggerTime_contains: String
  triggerTime_not_contains: String
  triggerTime_starts_with: String
  triggerTime_not_starts_with: String
  triggerTime_ends_with: String
  triggerTime_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  level: Level
  level_not: Level
  level_in: [Level!]
  level_not_in: [Level!]
  source: Source
  source_not: Source
  source_in: [Source!]
  source_not_in: [Source!]
  trigger: EntityWhereInput
  hour: HourWhereInput
  day: DayWhereInput
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
  alertID: Int
  logID: String
}

type LayoutLG {
  id: ID!
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: Card!
  grouping: Grouping!
}

type LayoutLGConnection {
  pageInfo: PageInfo!
  edges: [LayoutLGEdge]!
  aggregate: AggregateLayoutLG!
}

input LayoutLGCreateInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: CardCreateOneWithoutLayoutLGInput!
  grouping: GroupingCreateOneWithoutLayoutLGsInput!
}

input LayoutLGCreateManyWithoutGroupingInput {
  create: [LayoutLGCreateWithoutGroupingInput!]
  connect: [LayoutLGWhereUniqueInput!]
}

input LayoutLGCreateOneWithoutCardInput {
  create: LayoutLGCreateWithoutCardInput
  connect: LayoutLGWhereUniqueInput
}

input LayoutLGCreateWithoutCardInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  grouping: GroupingCreateOneWithoutLayoutLGsInput!
}

input LayoutLGCreateWithoutGroupingInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: CardCreateOneWithoutLayoutLGInput!
}

type LayoutLGEdge {
  node: LayoutLG!
  cursor: String!
}

enum LayoutLGOrderByInput {
  id_ASC
  id_DESC
  x_ASC
  x_DESC
  y_ASC
  y_DESC
  w_ASC
  w_DESC
  h_ASC
  h_DESC
}

type LayoutLGPreviousValues {
  id: ID!
  x: Int!
  y: Int!
  w: Int!
  h: Int!
}

input LayoutLGScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  w: Int
  w_not: Int
  w_in: [Int!]
  w_not_in: [Int!]
  w_lt: Int
  w_lte: Int
  w_gt: Int
  w_gte: Int
  h: Int
  h_not: Int
  h_in: [Int!]
  h_not_in: [Int!]
  h_lt: Int
  h_lte: Int
  h_gt: Int
  h_gte: Int
  AND: [LayoutLGScalarWhereInput!]
  OR: [LayoutLGScalarWhereInput!]
  NOT: [LayoutLGScalarWhereInput!]
}

type LayoutLGSubscriptionPayload {
  mutation: MutationType!
  node: LayoutLG
  updatedFields: [String!]
  previousValues: LayoutLGPreviousValues
}

input LayoutLGSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LayoutLGWhereInput
  AND: [LayoutLGSubscriptionWhereInput!]
  OR: [LayoutLGSubscriptionWhereInput!]
  NOT: [LayoutLGSubscriptionWhereInput!]
}

input LayoutLGUpdateInput {
  x: Int
  y: Int
  w: Int
  h: Int
  card: CardUpdateOneRequiredWithoutLayoutLGInput
  grouping: GroupingUpdateOneRequiredWithoutLayoutLGsInput
}

input LayoutLGUpdateManyDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
}

input LayoutLGUpdateManyMutationInput {
  x: Int
  y: Int
  w: Int
  h: Int
}

input LayoutLGUpdateManyWithoutGroupingInput {
  create: [LayoutLGCreateWithoutGroupingInput!]
  delete: [LayoutLGWhereUniqueInput!]
  connect: [LayoutLGWhereUniqueInput!]
  set: [LayoutLGWhereUniqueInput!]
  disconnect: [LayoutLGWhereUniqueInput!]
  update: [LayoutLGUpdateWithWhereUniqueWithoutGroupingInput!]
  upsert: [LayoutLGUpsertWithWhereUniqueWithoutGroupingInput!]
  deleteMany: [LayoutLGScalarWhereInput!]
  updateMany: [LayoutLGUpdateManyWithWhereNestedInput!]
}

input LayoutLGUpdateManyWithWhereNestedInput {
  where: LayoutLGScalarWhereInput!
  data: LayoutLGUpdateManyDataInput!
}

input LayoutLGUpdateOneRequiredWithoutCardInput {
  create: LayoutLGCreateWithoutCardInput
  update: LayoutLGUpdateWithoutCardDataInput
  upsert: LayoutLGUpsertWithoutCardInput
  connect: LayoutLGWhereUniqueInput
}

input LayoutLGUpdateWithoutCardDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
  grouping: GroupingUpdateOneRequiredWithoutLayoutLGsInput
}

input LayoutLGUpdateWithoutGroupingDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
  card: CardUpdateOneRequiredWithoutLayoutLGInput
}

input LayoutLGUpdateWithWhereUniqueWithoutGroupingInput {
  where: LayoutLGWhereUniqueInput!
  data: LayoutLGUpdateWithoutGroupingDataInput!
}

input LayoutLGUpsertWithoutCardInput {
  update: LayoutLGUpdateWithoutCardDataInput!
  create: LayoutLGCreateWithoutCardInput!
}

input LayoutLGUpsertWithWhereUniqueWithoutGroupingInput {
  where: LayoutLGWhereUniqueInput!
  update: LayoutLGUpdateWithoutGroupingDataInput!
  create: LayoutLGCreateWithoutGroupingInput!
}

input LayoutLGWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  w: Int
  w_not: Int
  w_in: [Int!]
  w_not_in: [Int!]
  w_lt: Int
  w_lte: Int
  w_gt: Int
  w_gte: Int
  h: Int
  h_not: Int
  h_in: [Int!]
  h_not_in: [Int!]
  h_lt: Int
  h_lte: Int
  h_gt: Int
  h_gte: Int
  card: CardWhereInput
  grouping: GroupingWhereInput
  AND: [LayoutLGWhereInput!]
  OR: [LayoutLGWhereInput!]
  NOT: [LayoutLGWhereInput!]
}

input LayoutLGWhereUniqueInput {
  id: ID
}

type LayoutMD {
  id: ID!
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: Card!
  grouping: Grouping!
}

type LayoutMDConnection {
  pageInfo: PageInfo!
  edges: [LayoutMDEdge]!
  aggregate: AggregateLayoutMD!
}

input LayoutMDCreateInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: CardCreateOneWithoutLayoutMDInput!
  grouping: GroupingCreateOneWithoutLayoutMDsInput!
}

input LayoutMDCreateManyWithoutGroupingInput {
  create: [LayoutMDCreateWithoutGroupingInput!]
  connect: [LayoutMDWhereUniqueInput!]
}

input LayoutMDCreateOneWithoutCardInput {
  create: LayoutMDCreateWithoutCardInput
  connect: LayoutMDWhereUniqueInput
}

input LayoutMDCreateWithoutCardInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  grouping: GroupingCreateOneWithoutLayoutMDsInput!
}

input LayoutMDCreateWithoutGroupingInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: CardCreateOneWithoutLayoutMDInput!
}

type LayoutMDEdge {
  node: LayoutMD!
  cursor: String!
}

enum LayoutMDOrderByInput {
  id_ASC
  id_DESC
  x_ASC
  x_DESC
  y_ASC
  y_DESC
  w_ASC
  w_DESC
  h_ASC
  h_DESC
}

type LayoutMDPreviousValues {
  id: ID!
  x: Int!
  y: Int!
  w: Int!
  h: Int!
}

input LayoutMDScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  w: Int
  w_not: Int
  w_in: [Int!]
  w_not_in: [Int!]
  w_lt: Int
  w_lte: Int
  w_gt: Int
  w_gte: Int
  h: Int
  h_not: Int
  h_in: [Int!]
  h_not_in: [Int!]
  h_lt: Int
  h_lte: Int
  h_gt: Int
  h_gte: Int
  AND: [LayoutMDScalarWhereInput!]
  OR: [LayoutMDScalarWhereInput!]
  NOT: [LayoutMDScalarWhereInput!]
}

type LayoutMDSubscriptionPayload {
  mutation: MutationType!
  node: LayoutMD
  updatedFields: [String!]
  previousValues: LayoutMDPreviousValues
}

input LayoutMDSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LayoutMDWhereInput
  AND: [LayoutMDSubscriptionWhereInput!]
  OR: [LayoutMDSubscriptionWhereInput!]
  NOT: [LayoutMDSubscriptionWhereInput!]
}

input LayoutMDUpdateInput {
  x: Int
  y: Int
  w: Int
  h: Int
  card: CardUpdateOneRequiredWithoutLayoutMDInput
  grouping: GroupingUpdateOneRequiredWithoutLayoutMDsInput
}

input LayoutMDUpdateManyDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
}

input LayoutMDUpdateManyMutationInput {
  x: Int
  y: Int
  w: Int
  h: Int
}

input LayoutMDUpdateManyWithoutGroupingInput {
  create: [LayoutMDCreateWithoutGroupingInput!]
  delete: [LayoutMDWhereUniqueInput!]
  connect: [LayoutMDWhereUniqueInput!]
  set: [LayoutMDWhereUniqueInput!]
  disconnect: [LayoutMDWhereUniqueInput!]
  update: [LayoutMDUpdateWithWhereUniqueWithoutGroupingInput!]
  upsert: [LayoutMDUpsertWithWhereUniqueWithoutGroupingInput!]
  deleteMany: [LayoutMDScalarWhereInput!]
  updateMany: [LayoutMDUpdateManyWithWhereNestedInput!]
}

input LayoutMDUpdateManyWithWhereNestedInput {
  where: LayoutMDScalarWhereInput!
  data: LayoutMDUpdateManyDataInput!
}

input LayoutMDUpdateOneRequiredWithoutCardInput {
  create: LayoutMDCreateWithoutCardInput
  update: LayoutMDUpdateWithoutCardDataInput
  upsert: LayoutMDUpsertWithoutCardInput
  connect: LayoutMDWhereUniqueInput
}

input LayoutMDUpdateWithoutCardDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
  grouping: GroupingUpdateOneRequiredWithoutLayoutMDsInput
}

input LayoutMDUpdateWithoutGroupingDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
  card: CardUpdateOneRequiredWithoutLayoutMDInput
}

input LayoutMDUpdateWithWhereUniqueWithoutGroupingInput {
  where: LayoutMDWhereUniqueInput!
  data: LayoutMDUpdateWithoutGroupingDataInput!
}

input LayoutMDUpsertWithoutCardInput {
  update: LayoutMDUpdateWithoutCardDataInput!
  create: LayoutMDCreateWithoutCardInput!
}

input LayoutMDUpsertWithWhereUniqueWithoutGroupingInput {
  where: LayoutMDWhereUniqueInput!
  update: LayoutMDUpdateWithoutGroupingDataInput!
  create: LayoutMDCreateWithoutGroupingInput!
}

input LayoutMDWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  w: Int
  w_not: Int
  w_in: [Int!]
  w_not_in: [Int!]
  w_lt: Int
  w_lte: Int
  w_gt: Int
  w_gte: Int
  h: Int
  h_not: Int
  h_in: [Int!]
  h_not_in: [Int!]
  h_lt: Int
  h_lte: Int
  h_gt: Int
  h_gte: Int
  card: CardWhereInput
  grouping: GroupingWhereInput
  AND: [LayoutMDWhereInput!]
  OR: [LayoutMDWhereInput!]
  NOT: [LayoutMDWhereInput!]
}

input LayoutMDWhereUniqueInput {
  id: ID
}

type LayoutSM {
  id: ID!
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: Card!
  grouping: Grouping!
}

type LayoutSMConnection {
  pageInfo: PageInfo!
  edges: [LayoutSMEdge]!
  aggregate: AggregateLayoutSM!
}

input LayoutSMCreateInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: CardCreateOneWithoutLayoutSMInput!
  grouping: GroupingCreateOneWithoutLayoutSMsInput!
}

input LayoutSMCreateManyWithoutGroupingInput {
  create: [LayoutSMCreateWithoutGroupingInput!]
  connect: [LayoutSMWhereUniqueInput!]
}

input LayoutSMCreateOneWithoutCardInput {
  create: LayoutSMCreateWithoutCardInput
  connect: LayoutSMWhereUniqueInput
}

input LayoutSMCreateWithoutCardInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  grouping: GroupingCreateOneWithoutLayoutSMsInput!
}

input LayoutSMCreateWithoutGroupingInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: CardCreateOneWithoutLayoutSMInput!
}

type LayoutSMEdge {
  node: LayoutSM!
  cursor: String!
}

enum LayoutSMOrderByInput {
  id_ASC
  id_DESC
  x_ASC
  x_DESC
  y_ASC
  y_DESC
  w_ASC
  w_DESC
  h_ASC
  h_DESC
}

type LayoutSMPreviousValues {
  id: ID!
  x: Int!
  y: Int!
  w: Int!
  h: Int!
}

input LayoutSMScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  w: Int
  w_not: Int
  w_in: [Int!]
  w_not_in: [Int!]
  w_lt: Int
  w_lte: Int
  w_gt: Int
  w_gte: Int
  h: Int
  h_not: Int
  h_in: [Int!]
  h_not_in: [Int!]
  h_lt: Int
  h_lte: Int
  h_gt: Int
  h_gte: Int
  AND: [LayoutSMScalarWhereInput!]
  OR: [LayoutSMScalarWhereInput!]
  NOT: [LayoutSMScalarWhereInput!]
}

type LayoutSMSubscriptionPayload {
  mutation: MutationType!
  node: LayoutSM
  updatedFields: [String!]
  previousValues: LayoutSMPreviousValues
}

input LayoutSMSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LayoutSMWhereInput
  AND: [LayoutSMSubscriptionWhereInput!]
  OR: [LayoutSMSubscriptionWhereInput!]
  NOT: [LayoutSMSubscriptionWhereInput!]
}

input LayoutSMUpdateInput {
  x: Int
  y: Int
  w: Int
  h: Int
  card: CardUpdateOneRequiredWithoutLayoutSMInput
  grouping: GroupingUpdateOneRequiredWithoutLayoutSMsInput
}

input LayoutSMUpdateManyDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
}

input LayoutSMUpdateManyMutationInput {
  x: Int
  y: Int
  w: Int
  h: Int
}

input LayoutSMUpdateManyWithoutGroupingInput {
  create: [LayoutSMCreateWithoutGroupingInput!]
  delete: [LayoutSMWhereUniqueInput!]
  connect: [LayoutSMWhereUniqueInput!]
  set: [LayoutSMWhereUniqueInput!]
  disconnect: [LayoutSMWhereUniqueInput!]
  update: [LayoutSMUpdateWithWhereUniqueWithoutGroupingInput!]
  upsert: [LayoutSMUpsertWithWhereUniqueWithoutGroupingInput!]
  deleteMany: [LayoutSMScalarWhereInput!]
  updateMany: [LayoutSMUpdateManyWithWhereNestedInput!]
}

input LayoutSMUpdateManyWithWhereNestedInput {
  where: LayoutSMScalarWhereInput!
  data: LayoutSMUpdateManyDataInput!
}

input LayoutSMUpdateOneRequiredWithoutCardInput {
  create: LayoutSMCreateWithoutCardInput
  update: LayoutSMUpdateWithoutCardDataInput
  upsert: LayoutSMUpsertWithoutCardInput
  connect: LayoutSMWhereUniqueInput
}

input LayoutSMUpdateWithoutCardDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
  grouping: GroupingUpdateOneRequiredWithoutLayoutSMsInput
}

input LayoutSMUpdateWithoutGroupingDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
  card: CardUpdateOneRequiredWithoutLayoutSMInput
}

input LayoutSMUpdateWithWhereUniqueWithoutGroupingInput {
  where: LayoutSMWhereUniqueInput!
  data: LayoutSMUpdateWithoutGroupingDataInput!
}

input LayoutSMUpsertWithoutCardInput {
  update: LayoutSMUpdateWithoutCardDataInput!
  create: LayoutSMCreateWithoutCardInput!
}

input LayoutSMUpsertWithWhereUniqueWithoutGroupingInput {
  where: LayoutSMWhereUniqueInput!
  update: LayoutSMUpdateWithoutGroupingDataInput!
  create: LayoutSMCreateWithoutGroupingInput!
}

input LayoutSMWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  w: Int
  w_not: Int
  w_in: [Int!]
  w_not_in: [Int!]
  w_lt: Int
  w_lte: Int
  w_gt: Int
  w_gte: Int
  h: Int
  h_not: Int
  h_in: [Int!]
  h_not_in: [Int!]
  h_lt: Int
  h_lte: Int
  h_gt: Int
  h_gte: Int
  card: CardWhereInput
  grouping: GroupingWhereInput
  AND: [LayoutSMWhereInput!]
  OR: [LayoutSMWhereInput!]
  NOT: [LayoutSMWhereInput!]
}

input LayoutSMWhereUniqueInput {
  id: ID
}

type LayoutXS {
  id: ID!
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: Card!
  grouping: Grouping!
}

type LayoutXSConnection {
  pageInfo: PageInfo!
  edges: [LayoutXSEdge]!
  aggregate: AggregateLayoutXS!
}

input LayoutXSCreateInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: CardCreateOneWithoutLayoutXSInput!
  grouping: GroupingCreateOneWithoutLayoutXSsInput!
}

input LayoutXSCreateManyWithoutGroupingInput {
  create: [LayoutXSCreateWithoutGroupingInput!]
  connect: [LayoutXSWhereUniqueInput!]
}

input LayoutXSCreateOneWithoutCardInput {
  create: LayoutXSCreateWithoutCardInput
  connect: LayoutXSWhereUniqueInput
}

input LayoutXSCreateWithoutCardInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  grouping: GroupingCreateOneWithoutLayoutXSsInput!
}

input LayoutXSCreateWithoutGroupingInput {
  id: ID
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  card: CardCreateOneWithoutLayoutXSInput!
}

type LayoutXSEdge {
  node: LayoutXS!
  cursor: String!
}

enum LayoutXSOrderByInput {
  id_ASC
  id_DESC
  x_ASC
  x_DESC
  y_ASC
  y_DESC
  w_ASC
  w_DESC
  h_ASC
  h_DESC
}

type LayoutXSPreviousValues {
  id: ID!
  x: Int!
  y: Int!
  w: Int!
  h: Int!
}

input LayoutXSScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  w: Int
  w_not: Int
  w_in: [Int!]
  w_not_in: [Int!]
  w_lt: Int
  w_lte: Int
  w_gt: Int
  w_gte: Int
  h: Int
  h_not: Int
  h_in: [Int!]
  h_not_in: [Int!]
  h_lt: Int
  h_lte: Int
  h_gt: Int
  h_gte: Int
  AND: [LayoutXSScalarWhereInput!]
  OR: [LayoutXSScalarWhereInput!]
  NOT: [LayoutXSScalarWhereInput!]
}

type LayoutXSSubscriptionPayload {
  mutation: MutationType!
  node: LayoutXS
  updatedFields: [String!]
  previousValues: LayoutXSPreviousValues
}

input LayoutXSSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LayoutXSWhereInput
  AND: [LayoutXSSubscriptionWhereInput!]
  OR: [LayoutXSSubscriptionWhereInput!]
  NOT: [LayoutXSSubscriptionWhereInput!]
}

input LayoutXSUpdateInput {
  x: Int
  y: Int
  w: Int
  h: Int
  card: CardUpdateOneRequiredWithoutLayoutXSInput
  grouping: GroupingUpdateOneRequiredWithoutLayoutXSsInput
}

input LayoutXSUpdateManyDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
}

input LayoutXSUpdateManyMutationInput {
  x: Int
  y: Int
  w: Int
  h: Int
}

input LayoutXSUpdateManyWithoutGroupingInput {
  create: [LayoutXSCreateWithoutGroupingInput!]
  delete: [LayoutXSWhereUniqueInput!]
  connect: [LayoutXSWhereUniqueInput!]
  set: [LayoutXSWhereUniqueInput!]
  disconnect: [LayoutXSWhereUniqueInput!]
  update: [LayoutXSUpdateWithWhereUniqueWithoutGroupingInput!]
  upsert: [LayoutXSUpsertWithWhereUniqueWithoutGroupingInput!]
  deleteMany: [LayoutXSScalarWhereInput!]
  updateMany: [LayoutXSUpdateManyWithWhereNestedInput!]
}

input LayoutXSUpdateManyWithWhereNestedInput {
  where: LayoutXSScalarWhereInput!
  data: LayoutXSUpdateManyDataInput!
}

input LayoutXSUpdateOneRequiredWithoutCardInput {
  create: LayoutXSCreateWithoutCardInput
  update: LayoutXSUpdateWithoutCardDataInput
  upsert: LayoutXSUpsertWithoutCardInput
  connect: LayoutXSWhereUniqueInput
}

input LayoutXSUpdateWithoutCardDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
  grouping: GroupingUpdateOneRequiredWithoutLayoutXSsInput
}

input LayoutXSUpdateWithoutGroupingDataInput {
  x: Int
  y: Int
  w: Int
  h: Int
  card: CardUpdateOneRequiredWithoutLayoutXSInput
}

input LayoutXSUpdateWithWhereUniqueWithoutGroupingInput {
  where: LayoutXSWhereUniqueInput!
  data: LayoutXSUpdateWithoutGroupingDataInput!
}

input LayoutXSUpsertWithoutCardInput {
  update: LayoutXSUpdateWithoutCardDataInput!
  create: LayoutXSCreateWithoutCardInput!
}

input LayoutXSUpsertWithWhereUniqueWithoutGroupingInput {
  where: LayoutXSWhereUniqueInput!
  update: LayoutXSUpdateWithoutGroupingDataInput!
  create: LayoutXSCreateWithoutGroupingInput!
}

input LayoutXSWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  w: Int
  w_not: Int
  w_in: [Int!]
  w_not_in: [Int!]
  w_lt: Int
  w_lte: Int
  w_gt: Int
  w_gte: Int
  h: Int
  h_not: Int
  h_in: [Int!]
  h_not_in: [Int!]
  h_lt: Int
  h_lte: Int
  h_gt: Int
  h_gte: Int
  card: CardWhereInput
  grouping: GroupingWhereInput
  AND: [LayoutXSWhereInput!]
  OR: [LayoutXSWhereInput!]
  NOT: [LayoutXSWhereInput!]
}

input LayoutXSWhereUniqueInput {
  id: ID
}

enum Level {
  CRITICAL
  INFORMATIONAL
  NOTICE
  SERIOUS
  WARNING
  ALERT
  EMERGENCY
  ERROR
  UNKNOWN
}

scalar Long

type Month {
  id: ID!
  value: Int!
  monthYear: String!
  year: Year!
  days(where: DayWhereInput, orderBy: DayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Day!]
}

type MonthConnection {
  pageInfo: PageInfo!
  edges: [MonthEdge]!
  aggregate: AggregateMonth!
}

input MonthCreateInput {
  id: ID
  value: Int!
  monthYear: String!
  year: YearCreateOneWithoutMonthsInput!
  days: DayCreateManyWithoutMonthInput
}

input MonthCreateManyWithoutYearInput {
  create: [MonthCreateWithoutYearInput!]
  connect: [MonthWhereUniqueInput!]
}

input MonthCreateOneWithoutDaysInput {
  create: MonthCreateWithoutDaysInput
  connect: MonthWhereUniqueInput
}

input MonthCreateWithoutDaysInput {
  id: ID
  value: Int!
  monthYear: String!
  year: YearCreateOneWithoutMonthsInput!
}

input MonthCreateWithoutYearInput {
  id: ID
  value: Int!
  monthYear: String!
  days: DayCreateManyWithoutMonthInput
}

type MonthEdge {
  node: Month!
  cursor: String!
}

enum MonthOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  monthYear_ASC
  monthYear_DESC
}

type MonthPreviousValues {
  id: ID!
  value: Int!
  monthYear: String!
}

input MonthScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  monthYear: String
  monthYear_not: String
  monthYear_in: [String!]
  monthYear_not_in: [String!]
  monthYear_lt: String
  monthYear_lte: String
  monthYear_gt: String
  monthYear_gte: String
  monthYear_contains: String
  monthYear_not_contains: String
  monthYear_starts_with: String
  monthYear_not_starts_with: String
  monthYear_ends_with: String
  monthYear_not_ends_with: String
  AND: [MonthScalarWhereInput!]
  OR: [MonthScalarWhereInput!]
  NOT: [MonthScalarWhereInput!]
}

type MonthSubscriptionPayload {
  mutation: MutationType!
  node: Month
  updatedFields: [String!]
  previousValues: MonthPreviousValues
}

input MonthSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MonthWhereInput
  AND: [MonthSubscriptionWhereInput!]
  OR: [MonthSubscriptionWhereInput!]
  NOT: [MonthSubscriptionWhereInput!]
}

input MonthUpdateInput {
  value: Int
  monthYear: String
  year: YearUpdateOneRequiredWithoutMonthsInput
  days: DayUpdateManyWithoutMonthInput
}

input MonthUpdateManyDataInput {
  value: Int
  monthYear: String
}

input MonthUpdateManyMutationInput {
  value: Int
  monthYear: String
}

input MonthUpdateManyWithoutYearInput {
  create: [MonthCreateWithoutYearInput!]
  delete: [MonthWhereUniqueInput!]
  connect: [MonthWhereUniqueInput!]
  set: [MonthWhereUniqueInput!]
  disconnect: [MonthWhereUniqueInput!]
  update: [MonthUpdateWithWhereUniqueWithoutYearInput!]
  upsert: [MonthUpsertWithWhereUniqueWithoutYearInput!]
  deleteMany: [MonthScalarWhereInput!]
  updateMany: [MonthUpdateManyWithWhereNestedInput!]
}

input MonthUpdateManyWithWhereNestedInput {
  where: MonthScalarWhereInput!
  data: MonthUpdateManyDataInput!
}

input MonthUpdateOneRequiredWithoutDaysInput {
  create: MonthCreateWithoutDaysInput
  update: MonthUpdateWithoutDaysDataInput
  upsert: MonthUpsertWithoutDaysInput
  connect: MonthWhereUniqueInput
}

input MonthUpdateWithoutDaysDataInput {
  value: Int
  monthYear: String
  year: YearUpdateOneRequiredWithoutMonthsInput
}

input MonthUpdateWithoutYearDataInput {
  value: Int
  monthYear: String
  days: DayUpdateManyWithoutMonthInput
}

input MonthUpdateWithWhereUniqueWithoutYearInput {
  where: MonthWhereUniqueInput!
  data: MonthUpdateWithoutYearDataInput!
}

input MonthUpsertWithoutDaysInput {
  update: MonthUpdateWithoutDaysDataInput!
  create: MonthCreateWithoutDaysInput!
}

input MonthUpsertWithWhereUniqueWithoutYearInput {
  where: MonthWhereUniqueInput!
  update: MonthUpdateWithoutYearDataInput!
  create: MonthCreateWithoutYearInput!
}

input MonthWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  monthYear: String
  monthYear_not: String
  monthYear_in: [String!]
  monthYear_not_in: [String!]
  monthYear_lt: String
  monthYear_lte: String
  monthYear_gt: String
  monthYear_gte: String
  monthYear_contains: String
  monthYear_not_contains: String
  monthYear_starts_with: String
  monthYear_not_starts_with: String
  monthYear_ends_with: String
  monthYear_not_ends_with: String
  year: YearWhereInput
  days_every: DayWhereInput
  days_some: DayWhereInput
  days_none: DayWhereInput
  AND: [MonthWhereInput!]
  OR: [MonthWhereInput!]
  NOT: [MonthWhereInput!]
}

input MonthWhereUniqueInput {
  id: ID
  monthYear: String
}

type Mutation {
  createCard(data: CardCreateInput!): Card!
  updateCard(data: CardUpdateInput!, where: CardWhereUniqueInput!): Card
  updateManyCards(data: CardUpdateManyMutationInput!, where: CardWhereInput): BatchPayload!
  upsertCard(where: CardWhereUniqueInput!, create: CardCreateInput!, update: CardUpdateInput!): Card!
  deleteCard(where: CardWhereUniqueInput!): Card
  deleteManyCards(where: CardWhereInput): BatchPayload!
  createDashboard(data: DashboardCreateInput!): Dashboard!
  updateDashboard(data: DashboardUpdateInput!, where: DashboardWhereUniqueInput!): Dashboard
  updateManyDashboards(data: DashboardUpdateManyMutationInput!, where: DashboardWhereInput): BatchPayload!
  upsertDashboard(where: DashboardWhereUniqueInput!, create: DashboardCreateInput!, update: DashboardUpdateInput!): Dashboard!
  deleteDashboard(where: DashboardWhereUniqueInput!): Dashboard
  deleteManyDashboards(where: DashboardWhereInput): BatchPayload!
  createDay(data: DayCreateInput!): Day!
  updateDay(data: DayUpdateInput!, where: DayWhereUniqueInput!): Day
  updateManyDays(data: DayUpdateManyMutationInput!, where: DayWhereInput): BatchPayload!
  upsertDay(where: DayWhereUniqueInput!, create: DayCreateInput!, update: DayUpdateInput!): Day!
  deleteDay(where: DayWhereUniqueInput!): Day
  deleteManyDays(where: DayWhereInput): BatchPayload!
  createEntity(data: EntityCreateInput!): Entity!
  updateEntity(data: EntityUpdateInput!, where: EntityWhereUniqueInput!): Entity
  updateManyEntities(data: EntityUpdateManyMutationInput!, where: EntityWhereInput): BatchPayload!
  upsertEntity(where: EntityWhereUniqueInput!, create: EntityCreateInput!, update: EntityUpdateInput!): Entity!
  deleteEntity(where: EntityWhereUniqueInput!): Entity
  deleteManyEntities(where: EntityWhereInput): BatchPayload!
  createGrouping(data: GroupingCreateInput!): Grouping!
  updateGrouping(data: GroupingUpdateInput!, where: GroupingWhereUniqueInput!): Grouping
  updateManyGroupings(data: GroupingUpdateManyMutationInput!, where: GroupingWhereInput): BatchPayload!
  upsertGrouping(where: GroupingWhereUniqueInput!, create: GroupingCreateInput!, update: GroupingUpdateInput!): Grouping!
  deleteGrouping(where: GroupingWhereUniqueInput!): Grouping
  deleteManyGroupings(where: GroupingWhereInput): BatchPayload!
  createHour(data: HourCreateInput!): Hour!
  updateHour(data: HourUpdateInput!, where: HourWhereUniqueInput!): Hour
  updateManyHours(data: HourUpdateManyMutationInput!, where: HourWhereInput): BatchPayload!
  upsertHour(where: HourWhereUniqueInput!, create: HourCreateInput!, update: HourUpdateInput!): Hour!
  deleteHour(where: HourWhereUniqueInput!): Hour
  deleteManyHours(where: HourWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createLayoutLG(data: LayoutLGCreateInput!): LayoutLG!
  updateLayoutLG(data: LayoutLGUpdateInput!, where: LayoutLGWhereUniqueInput!): LayoutLG
  updateManyLayoutLGs(data: LayoutLGUpdateManyMutationInput!, where: LayoutLGWhereInput): BatchPayload!
  upsertLayoutLG(where: LayoutLGWhereUniqueInput!, create: LayoutLGCreateInput!, update: LayoutLGUpdateInput!): LayoutLG!
  deleteLayoutLG(where: LayoutLGWhereUniqueInput!): LayoutLG
  deleteManyLayoutLGs(where: LayoutLGWhereInput): BatchPayload!
  createLayoutMD(data: LayoutMDCreateInput!): LayoutMD!
  updateLayoutMD(data: LayoutMDUpdateInput!, where: LayoutMDWhereUniqueInput!): LayoutMD
  updateManyLayoutMDs(data: LayoutMDUpdateManyMutationInput!, where: LayoutMDWhereInput): BatchPayload!
  upsertLayoutMD(where: LayoutMDWhereUniqueInput!, create: LayoutMDCreateInput!, update: LayoutMDUpdateInput!): LayoutMD!
  deleteLayoutMD(where: LayoutMDWhereUniqueInput!): LayoutMD
  deleteManyLayoutMDs(where: LayoutMDWhereInput): BatchPayload!
  createLayoutSM(data: LayoutSMCreateInput!): LayoutSM!
  updateLayoutSM(data: LayoutSMUpdateInput!, where: LayoutSMWhereUniqueInput!): LayoutSM
  updateManyLayoutSMs(data: LayoutSMUpdateManyMutationInput!, where: LayoutSMWhereInput): BatchPayload!
  upsertLayoutSM(where: LayoutSMWhereUniqueInput!, create: LayoutSMCreateInput!, update: LayoutSMUpdateInput!): LayoutSM!
  deleteLayoutSM(where: LayoutSMWhereUniqueInput!): LayoutSM
  deleteManyLayoutSMs(where: LayoutSMWhereInput): BatchPayload!
  createLayoutXS(data: LayoutXSCreateInput!): LayoutXS!
  updateLayoutXS(data: LayoutXSUpdateInput!, where: LayoutXSWhereUniqueInput!): LayoutXS
  updateManyLayoutXses(data: LayoutXSUpdateManyMutationInput!, where: LayoutXSWhereInput): BatchPayload!
  upsertLayoutXS(where: LayoutXSWhereUniqueInput!, create: LayoutXSCreateInput!, update: LayoutXSUpdateInput!): LayoutXS!
  deleteLayoutXS(where: LayoutXSWhereUniqueInput!): LayoutXS
  deleteManyLayoutXses(where: LayoutXSWhereInput): BatchPayload!
  createMonth(data: MonthCreateInput!): Month!
  updateMonth(data: MonthUpdateInput!, where: MonthWhereUniqueInput!): Month
  updateManyMonths(data: MonthUpdateManyMutationInput!, where: MonthWhereInput): BatchPayload!
  upsertMonth(where: MonthWhereUniqueInput!, create: MonthCreateInput!, update: MonthUpdateInput!): Month!
  deleteMonth(where: MonthWhereUniqueInput!): Month
  deleteManyMonths(where: MonthWhereInput): BatchPayload!
  createQuarter(data: QuarterCreateInput!): Quarter!
  updateQuarter(data: QuarterUpdateInput!, where: QuarterWhereUniqueInput!): Quarter
  updateManyQuarters(data: QuarterUpdateManyMutationInput!, where: QuarterWhereInput): BatchPayload!
  upsertQuarter(where: QuarterWhereUniqueInput!, create: QuarterCreateInput!, update: QuarterUpdateInput!): Quarter!
  deleteQuarter(where: QuarterWhereUniqueInput!): Quarter
  deleteManyQuarters(where: QuarterWhereInput): BatchPayload!
  createWeek(data: WeekCreateInput!): Week!
  updateWeek(data: WeekUpdateInput!, where: WeekWhereUniqueInput!): Week
  updateManyWeeks(data: WeekUpdateManyMutationInput!, where: WeekWhereInput): BatchPayload!
  upsertWeek(where: WeekWhereUniqueInput!, create: WeekCreateInput!, update: WeekUpdateInput!): Week!
  deleteWeek(where: WeekWhereUniqueInput!): Week
  deleteManyWeeks(where: WeekWhereInput): BatchPayload!
  createYear(data: YearCreateInput!): Year!
  updateYear(data: YearUpdateInput!, where: YearWhereUniqueInput!): Year
  updateManyYears(data: YearUpdateManyMutationInput!, where: YearWhereInput): BatchPayload!
  upsertYear(where: YearWhereUniqueInput!, create: YearCreateInput!, update: YearUpdateInput!): Year!
  deleteYear(where: YearWhereUniqueInput!): Year
  deleteManyYears(where: YearWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Quarter {
  id: ID!
  value: Int!
  quarterYear: String!
  year: Year!
  days(where: DayWhereInput, orderBy: DayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Day!]
}

type QuarterConnection {
  pageInfo: PageInfo!
  edges: [QuarterEdge]!
  aggregate: AggregateQuarter!
}

input QuarterCreateInput {
  id: ID
  value: Int!
  quarterYear: String!
  year: YearCreateOneWithoutQuartersInput!
  days: DayCreateManyWithoutQuarterInput
}

input QuarterCreateManyWithoutYearInput {
  create: [QuarterCreateWithoutYearInput!]
  connect: [QuarterWhereUniqueInput!]
}

input QuarterCreateOneWithoutDaysInput {
  create: QuarterCreateWithoutDaysInput
  connect: QuarterWhereUniqueInput
}

input QuarterCreateWithoutDaysInput {
  id: ID
  value: Int!
  quarterYear: String!
  year: YearCreateOneWithoutQuartersInput!
}

input QuarterCreateWithoutYearInput {
  id: ID
  value: Int!
  quarterYear: String!
  days: DayCreateManyWithoutQuarterInput
}

type QuarterEdge {
  node: Quarter!
  cursor: String!
}

enum QuarterOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  quarterYear_ASC
  quarterYear_DESC
}

type QuarterPreviousValues {
  id: ID!
  value: Int!
  quarterYear: String!
}

input QuarterScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  quarterYear: String
  quarterYear_not: String
  quarterYear_in: [String!]
  quarterYear_not_in: [String!]
  quarterYear_lt: String
  quarterYear_lte: String
  quarterYear_gt: String
  quarterYear_gte: String
  quarterYear_contains: String
  quarterYear_not_contains: String
  quarterYear_starts_with: String
  quarterYear_not_starts_with: String
  quarterYear_ends_with: String
  quarterYear_not_ends_with: String
  AND: [QuarterScalarWhereInput!]
  OR: [QuarterScalarWhereInput!]
  NOT: [QuarterScalarWhereInput!]
}

type QuarterSubscriptionPayload {
  mutation: MutationType!
  node: Quarter
  updatedFields: [String!]
  previousValues: QuarterPreviousValues
}

input QuarterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuarterWhereInput
  AND: [QuarterSubscriptionWhereInput!]
  OR: [QuarterSubscriptionWhereInput!]
  NOT: [QuarterSubscriptionWhereInput!]
}

input QuarterUpdateInput {
  value: Int
  quarterYear: String
  year: YearUpdateOneRequiredWithoutQuartersInput
  days: DayUpdateManyWithoutQuarterInput
}

input QuarterUpdateManyDataInput {
  value: Int
  quarterYear: String
}

input QuarterUpdateManyMutationInput {
  value: Int
  quarterYear: String
}

input QuarterUpdateManyWithoutYearInput {
  create: [QuarterCreateWithoutYearInput!]
  delete: [QuarterWhereUniqueInput!]
  connect: [QuarterWhereUniqueInput!]
  set: [QuarterWhereUniqueInput!]
  disconnect: [QuarterWhereUniqueInput!]
  update: [QuarterUpdateWithWhereUniqueWithoutYearInput!]
  upsert: [QuarterUpsertWithWhereUniqueWithoutYearInput!]
  deleteMany: [QuarterScalarWhereInput!]
  updateMany: [QuarterUpdateManyWithWhereNestedInput!]
}

input QuarterUpdateManyWithWhereNestedInput {
  where: QuarterScalarWhereInput!
  data: QuarterUpdateManyDataInput!
}

input QuarterUpdateOneRequiredWithoutDaysInput {
  create: QuarterCreateWithoutDaysInput
  update: QuarterUpdateWithoutDaysDataInput
  upsert: QuarterUpsertWithoutDaysInput
  connect: QuarterWhereUniqueInput
}

input QuarterUpdateWithoutDaysDataInput {
  value: Int
  quarterYear: String
  year: YearUpdateOneRequiredWithoutQuartersInput
}

input QuarterUpdateWithoutYearDataInput {
  value: Int
  quarterYear: String
  days: DayUpdateManyWithoutQuarterInput
}

input QuarterUpdateWithWhereUniqueWithoutYearInput {
  where: QuarterWhereUniqueInput!
  data: QuarterUpdateWithoutYearDataInput!
}

input QuarterUpsertWithoutDaysInput {
  update: QuarterUpdateWithoutDaysDataInput!
  create: QuarterCreateWithoutDaysInput!
}

input QuarterUpsertWithWhereUniqueWithoutYearInput {
  where: QuarterWhereUniqueInput!
  update: QuarterUpdateWithoutYearDataInput!
  create: QuarterCreateWithoutYearInput!
}

input QuarterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  quarterYear: String
  quarterYear_not: String
  quarterYear_in: [String!]
  quarterYear_not_in: [String!]
  quarterYear_lt: String
  quarterYear_lte: String
  quarterYear_gt: String
  quarterYear_gte: String
  quarterYear_contains: String
  quarterYear_not_contains: String
  quarterYear_starts_with: String
  quarterYear_not_starts_with: String
  quarterYear_ends_with: String
  quarterYear_not_ends_with: String
  year: YearWhereInput
  days_every: DayWhereInput
  days_some: DayWhereInput
  days_none: DayWhereInput
  AND: [QuarterWhereInput!]
  OR: [QuarterWhereInput!]
  NOT: [QuarterWhereInput!]
}

input QuarterWhereUniqueInput {
  id: ID
  quarterYear: String
}

type Query {
  card(where: CardWhereUniqueInput!): Card
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card]!
  cardsConnection(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CardConnection!
  dashboard(where: DashboardWhereUniqueInput!): Dashboard
  dashboards(where: DashboardWhereInput, orderBy: DashboardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Dashboard]!
  dashboardsConnection(where: DashboardWhereInput, orderBy: DashboardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DashboardConnection!
  day(where: DayWhereUniqueInput!): Day
  days(where: DayWhereInput, orderBy: DayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Day]!
  daysConnection(where: DayWhereInput, orderBy: DayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DayConnection!
  entity(where: EntityWhereUniqueInput!): Entity
  entities(where: EntityWhereInput, orderBy: EntityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Entity]!
  entitiesConnection(where: EntityWhereInput, orderBy: EntityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EntityConnection!
  grouping(where: GroupingWhereUniqueInput!): Grouping
  groupings(where: GroupingWhereInput, orderBy: GroupingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Grouping]!
  groupingsConnection(where: GroupingWhereInput, orderBy: GroupingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupingConnection!
  hour(where: HourWhereUniqueInput!): Hour
  hours(where: HourWhereInput, orderBy: HourOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hour]!
  hoursConnection(where: HourWhereInput, orderBy: HourOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HourConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  layoutLG(where: LayoutLGWhereUniqueInput!): LayoutLG
  layoutLGs(where: LayoutLGWhereInput, orderBy: LayoutLGOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LayoutLG]!
  layoutLGsConnection(where: LayoutLGWhereInput, orderBy: LayoutLGOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LayoutLGConnection!
  layoutMD(where: LayoutMDWhereUniqueInput!): LayoutMD
  layoutMDs(where: LayoutMDWhereInput, orderBy: LayoutMDOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LayoutMD]!
  layoutMDsConnection(where: LayoutMDWhereInput, orderBy: LayoutMDOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LayoutMDConnection!
  layoutSM(where: LayoutSMWhereUniqueInput!): LayoutSM
  layoutSMs(where: LayoutSMWhereInput, orderBy: LayoutSMOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LayoutSM]!
  layoutSMsConnection(where: LayoutSMWhereInput, orderBy: LayoutSMOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LayoutSMConnection!
  layoutXS(where: LayoutXSWhereUniqueInput!): LayoutXS
  layoutXses(where: LayoutXSWhereInput, orderBy: LayoutXSOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LayoutXS]!
  layoutXsesConnection(where: LayoutXSWhereInput, orderBy: LayoutXSOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LayoutXSConnection!
  month(where: MonthWhereUniqueInput!): Month
  months(where: MonthWhereInput, orderBy: MonthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Month]!
  monthsConnection(where: MonthWhereInput, orderBy: MonthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MonthConnection!
  quarter(where: QuarterWhereUniqueInput!): Quarter
  quarters(where: QuarterWhereInput, orderBy: QuarterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quarter]!
  quartersConnection(where: QuarterWhereInput, orderBy: QuarterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuarterConnection!
  week(where: WeekWhereUniqueInput!): Week
  weeks(where: WeekWhereInput, orderBy: WeekOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Week]!
  weeksConnection(where: WeekWhereInput, orderBy: WeekOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WeekConnection!
  year(where: YearWhereUniqueInput!): Year
  years(where: YearWhereInput, orderBy: YearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Year]!
  yearsConnection(where: YearWhereInput, orderBy: YearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): YearConnection!
  node(id: ID!): Node
}

enum Source {
  ORION
  SPLUNK
  OTHER
}

type Subscription {
  card(where: CardSubscriptionWhereInput): CardSubscriptionPayload
  dashboard(where: DashboardSubscriptionWhereInput): DashboardSubscriptionPayload
  day(where: DaySubscriptionWhereInput): DaySubscriptionPayload
  entity(where: EntitySubscriptionWhereInput): EntitySubscriptionPayload
  grouping(where: GroupingSubscriptionWhereInput): GroupingSubscriptionPayload
  hour(where: HourSubscriptionWhereInput): HourSubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  layoutLG(where: LayoutLGSubscriptionWhereInput): LayoutLGSubscriptionPayload
  layoutMD(where: LayoutMDSubscriptionWhereInput): LayoutMDSubscriptionPayload
  layoutSM(where: LayoutSMSubscriptionWhereInput): LayoutSMSubscriptionPayload
  layoutXS(where: LayoutXSSubscriptionWhereInput): LayoutXSSubscriptionPayload
  month(where: MonthSubscriptionWhereInput): MonthSubscriptionPayload
  quarter(where: QuarterSubscriptionWhereInput): QuarterSubscriptionPayload
  week(where: WeekSubscriptionWhereInput): WeekSubscriptionPayload
  year(where: YearSubscriptionWhereInput): YearSubscriptionPayload
}

type Week {
  id: ID!
  value: Int!
  weekYear: String!
  year: Year!
  days(where: DayWhereInput, orderBy: DayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Day!]
}

type WeekConnection {
  pageInfo: PageInfo!
  edges: [WeekEdge]!
  aggregate: AggregateWeek!
}

input WeekCreateInput {
  id: ID
  value: Int!
  weekYear: String!
  year: YearCreateOneWithoutWeeksInput!
  days: DayCreateManyWithoutWeekInput
}

input WeekCreateManyWithoutYearInput {
  create: [WeekCreateWithoutYearInput!]
  connect: [WeekWhereUniqueInput!]
}

input WeekCreateOneWithoutDaysInput {
  create: WeekCreateWithoutDaysInput
  connect: WeekWhereUniqueInput
}

input WeekCreateWithoutDaysInput {
  id: ID
  value: Int!
  weekYear: String!
  year: YearCreateOneWithoutWeeksInput!
}

input WeekCreateWithoutYearInput {
  id: ID
  value: Int!
  weekYear: String!
  days: DayCreateManyWithoutWeekInput
}

type WeekEdge {
  node: Week!
  cursor: String!
}

enum WeekOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  weekYear_ASC
  weekYear_DESC
}

type WeekPreviousValues {
  id: ID!
  value: Int!
  weekYear: String!
}

input WeekScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  weekYear: String
  weekYear_not: String
  weekYear_in: [String!]
  weekYear_not_in: [String!]
  weekYear_lt: String
  weekYear_lte: String
  weekYear_gt: String
  weekYear_gte: String
  weekYear_contains: String
  weekYear_not_contains: String
  weekYear_starts_with: String
  weekYear_not_starts_with: String
  weekYear_ends_with: String
  weekYear_not_ends_with: String
  AND: [WeekScalarWhereInput!]
  OR: [WeekScalarWhereInput!]
  NOT: [WeekScalarWhereInput!]
}

type WeekSubscriptionPayload {
  mutation: MutationType!
  node: Week
  updatedFields: [String!]
  previousValues: WeekPreviousValues
}

input WeekSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WeekWhereInput
  AND: [WeekSubscriptionWhereInput!]
  OR: [WeekSubscriptionWhereInput!]
  NOT: [WeekSubscriptionWhereInput!]
}

input WeekUpdateInput {
  value: Int
  weekYear: String
  year: YearUpdateOneRequiredWithoutWeeksInput
  days: DayUpdateManyWithoutWeekInput
}

input WeekUpdateManyDataInput {
  value: Int
  weekYear: String
}

input WeekUpdateManyMutationInput {
  value: Int
  weekYear: String
}

input WeekUpdateManyWithoutYearInput {
  create: [WeekCreateWithoutYearInput!]
  delete: [WeekWhereUniqueInput!]
  connect: [WeekWhereUniqueInput!]
  set: [WeekWhereUniqueInput!]
  disconnect: [WeekWhereUniqueInput!]
  update: [WeekUpdateWithWhereUniqueWithoutYearInput!]
  upsert: [WeekUpsertWithWhereUniqueWithoutYearInput!]
  deleteMany: [WeekScalarWhereInput!]
  updateMany: [WeekUpdateManyWithWhereNestedInput!]
}

input WeekUpdateManyWithWhereNestedInput {
  where: WeekScalarWhereInput!
  data: WeekUpdateManyDataInput!
}

input WeekUpdateOneRequiredWithoutDaysInput {
  create: WeekCreateWithoutDaysInput
  update: WeekUpdateWithoutDaysDataInput
  upsert: WeekUpsertWithoutDaysInput
  connect: WeekWhereUniqueInput
}

input WeekUpdateWithoutDaysDataInput {
  value: Int
  weekYear: String
  year: YearUpdateOneRequiredWithoutWeeksInput
}

input WeekUpdateWithoutYearDataInput {
  value: Int
  weekYear: String
  days: DayUpdateManyWithoutWeekInput
}

input WeekUpdateWithWhereUniqueWithoutYearInput {
  where: WeekWhereUniqueInput!
  data: WeekUpdateWithoutYearDataInput!
}

input WeekUpsertWithoutDaysInput {
  update: WeekUpdateWithoutDaysDataInput!
  create: WeekCreateWithoutDaysInput!
}

input WeekUpsertWithWhereUniqueWithoutYearInput {
  where: WeekWhereUniqueInput!
  update: WeekUpdateWithoutYearDataInput!
  create: WeekCreateWithoutYearInput!
}

input WeekWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  weekYear: String
  weekYear_not: String
  weekYear_in: [String!]
  weekYear_not_in: [String!]
  weekYear_lt: String
  weekYear_lte: String
  weekYear_gt: String
  weekYear_gte: String
  weekYear_contains: String
  weekYear_not_contains: String
  weekYear_starts_with: String
  weekYear_not_starts_with: String
  weekYear_ends_with: String
  weekYear_not_ends_with: String
  year: YearWhereInput
  days_every: DayWhereInput
  days_some: DayWhereInput
  days_none: DayWhereInput
  AND: [WeekWhereInput!]
  OR: [WeekWhereInput!]
  NOT: [WeekWhereInput!]
}

input WeekWhereUniqueInput {
  id: ID
  weekYear: String
}

type Year {
  id: ID!
  value: Int!
  quarters(where: QuarterWhereInput, orderBy: QuarterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quarter!]
  months(where: MonthWhereInput, orderBy: MonthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Month!]
  weeks(where: WeekWhereInput, orderBy: WeekOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Week!]
}

type YearConnection {
  pageInfo: PageInfo!
  edges: [YearEdge]!
  aggregate: AggregateYear!
}

input YearCreateInput {
  id: ID
  value: Int!
  quarters: QuarterCreateManyWithoutYearInput
  months: MonthCreateManyWithoutYearInput
  weeks: WeekCreateManyWithoutYearInput
}

input YearCreateOneInput {
  create: YearCreateInput
  connect: YearWhereUniqueInput
}

input YearCreateOneWithoutMonthsInput {
  create: YearCreateWithoutMonthsInput
  connect: YearWhereUniqueInput
}

input YearCreateOneWithoutQuartersInput {
  create: YearCreateWithoutQuartersInput
  connect: YearWhereUniqueInput
}

input YearCreateOneWithoutWeeksInput {
  create: YearCreateWithoutWeeksInput
  connect: YearWhereUniqueInput
}

input YearCreateWithoutMonthsInput {
  id: ID
  value: Int!
  quarters: QuarterCreateManyWithoutYearInput
  weeks: WeekCreateManyWithoutYearInput
}

input YearCreateWithoutQuartersInput {
  id: ID
  value: Int!
  months: MonthCreateManyWithoutYearInput
  weeks: WeekCreateManyWithoutYearInput
}

input YearCreateWithoutWeeksInput {
  id: ID
  value: Int!
  quarters: QuarterCreateManyWithoutYearInput
  months: MonthCreateManyWithoutYearInput
}

type YearEdge {
  node: Year!
  cursor: String!
}

enum YearOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
}

type YearPreviousValues {
  id: ID!
  value: Int!
}

type YearSubscriptionPayload {
  mutation: MutationType!
  node: Year
  updatedFields: [String!]
  previousValues: YearPreviousValues
}

input YearSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: YearWhereInput
  AND: [YearSubscriptionWhereInput!]
  OR: [YearSubscriptionWhereInput!]
  NOT: [YearSubscriptionWhereInput!]
}

input YearUpdateDataInput {
  value: Int
  quarters: QuarterUpdateManyWithoutYearInput
  months: MonthUpdateManyWithoutYearInput
  weeks: WeekUpdateManyWithoutYearInput
}

input YearUpdateInput {
  value: Int
  quarters: QuarterUpdateManyWithoutYearInput
  months: MonthUpdateManyWithoutYearInput
  weeks: WeekUpdateManyWithoutYearInput
}

input YearUpdateManyMutationInput {
  value: Int
}

input YearUpdateOneRequiredInput {
  create: YearCreateInput
  update: YearUpdateDataInput
  upsert: YearUpsertNestedInput
  connect: YearWhereUniqueInput
}

input YearUpdateOneRequiredWithoutMonthsInput {
  create: YearCreateWithoutMonthsInput
  update: YearUpdateWithoutMonthsDataInput
  upsert: YearUpsertWithoutMonthsInput
  connect: YearWhereUniqueInput
}

input YearUpdateOneRequiredWithoutQuartersInput {
  create: YearCreateWithoutQuartersInput
  update: YearUpdateWithoutQuartersDataInput
  upsert: YearUpsertWithoutQuartersInput
  connect: YearWhereUniqueInput
}

input YearUpdateOneRequiredWithoutWeeksInput {
  create: YearCreateWithoutWeeksInput
  update: YearUpdateWithoutWeeksDataInput
  upsert: YearUpsertWithoutWeeksInput
  connect: YearWhereUniqueInput
}

input YearUpdateWithoutMonthsDataInput {
  value: Int
  quarters: QuarterUpdateManyWithoutYearInput
  weeks: WeekUpdateManyWithoutYearInput
}

input YearUpdateWithoutQuartersDataInput {
  value: Int
  months: MonthUpdateManyWithoutYearInput
  weeks: WeekUpdateManyWithoutYearInput
}

input YearUpdateWithoutWeeksDataInput {
  value: Int
  quarters: QuarterUpdateManyWithoutYearInput
  months: MonthUpdateManyWithoutYearInput
}

input YearUpsertNestedInput {
  update: YearUpdateDataInput!
  create: YearCreateInput!
}

input YearUpsertWithoutMonthsInput {
  update: YearUpdateWithoutMonthsDataInput!
  create: YearCreateWithoutMonthsInput!
}

input YearUpsertWithoutQuartersInput {
  update: YearUpdateWithoutQuartersDataInput!
  create: YearCreateWithoutQuartersInput!
}

input YearUpsertWithoutWeeksInput {
  update: YearUpdateWithoutWeeksDataInput!
  create: YearCreateWithoutWeeksInput!
}

input YearWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  quarters_every: QuarterWhereInput
  quarters_some: QuarterWhereInput
  quarters_none: QuarterWhereInput
  months_every: MonthWhereInput
  months_some: MonthWhereInput
  months_none: MonthWhereInput
  weeks_every: WeekWhereInput
  weeks_some: WeekWhereInput
  weeks_none: WeekWhereInput
  AND: [YearWhereInput!]
  OR: [YearWhereInput!]
  NOT: [YearWhereInput!]
}

input YearWhereUniqueInput {
  id: ID
  value: Int
}
`
      }
    