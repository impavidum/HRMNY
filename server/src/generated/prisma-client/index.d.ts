// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  card: (where?: CardWhereInput) => Promise<boolean>;
  dashboard: (where?: DashboardWhereInput) => Promise<boolean>;
  day: (where?: DayWhereInput) => Promise<boolean>;
  entity: (where?: EntityWhereInput) => Promise<boolean>;
  grouping: (where?: GroupingWhereInput) => Promise<boolean>;
  hour: (where?: HourWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  layoutLG: (where?: LayoutLGWhereInput) => Promise<boolean>;
  layoutMD: (where?: LayoutMDWhereInput) => Promise<boolean>;
  layoutSM: (where?: LayoutSMWhereInput) => Promise<boolean>;
  layoutXS: (where?: LayoutXSWhereInput) => Promise<boolean>;
  month: (where?: MonthWhereInput) => Promise<boolean>;
  quarter: (where?: QuarterWhereInput) => Promise<boolean>;
  week: (where?: WeekWhereInput) => Promise<boolean>;
  year: (where?: YearWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  card: (where: CardWhereUniqueInput) => CardNullablePromise;
  cards: (args?: {
    where?: CardWhereInput;
    orderBy?: CardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Card>;
  cardsConnection: (args?: {
    where?: CardWhereInput;
    orderBy?: CardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CardConnectionPromise;
  dashboard: (where: DashboardWhereUniqueInput) => DashboardNullablePromise;
  dashboards: (args?: {
    where?: DashboardWhereInput;
    orderBy?: DashboardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Dashboard>;
  dashboardsConnection: (args?: {
    where?: DashboardWhereInput;
    orderBy?: DashboardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DashboardConnectionPromise;
  day: (where: DayWhereUniqueInput) => DayNullablePromise;
  days: (args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Day>;
  daysConnection: (args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DayConnectionPromise;
  entity: (where: EntityWhereUniqueInput) => EntityNullablePromise;
  entities: (args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Entity>;
  entitiesConnection: (args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityConnectionPromise;
  grouping: (where: GroupingWhereUniqueInput) => GroupingNullablePromise;
  groupings: (args?: {
    where?: GroupingWhereInput;
    orderBy?: GroupingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Grouping>;
  groupingsConnection: (args?: {
    where?: GroupingWhereInput;
    orderBy?: GroupingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GroupingConnectionPromise;
  hour: (where: HourWhereUniqueInput) => HourNullablePromise;
  hours: (args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Hour>;
  hoursConnection: (args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HourConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  layoutLG: (where: LayoutLGWhereUniqueInput) => LayoutLGNullablePromise;
  layoutLGs: (args?: {
    where?: LayoutLGWhereInput;
    orderBy?: LayoutLGOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LayoutLG>;
  layoutLGsConnection: (args?: {
    where?: LayoutLGWhereInput;
    orderBy?: LayoutLGOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LayoutLGConnectionPromise;
  layoutMD: (where: LayoutMDWhereUniqueInput) => LayoutMDNullablePromise;
  layoutMDs: (args?: {
    where?: LayoutMDWhereInput;
    orderBy?: LayoutMDOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LayoutMD>;
  layoutMDsConnection: (args?: {
    where?: LayoutMDWhereInput;
    orderBy?: LayoutMDOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LayoutMDConnectionPromise;
  layoutSM: (where: LayoutSMWhereUniqueInput) => LayoutSMNullablePromise;
  layoutSMs: (args?: {
    where?: LayoutSMWhereInput;
    orderBy?: LayoutSMOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LayoutSM>;
  layoutSMsConnection: (args?: {
    where?: LayoutSMWhereInput;
    orderBy?: LayoutSMOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LayoutSMConnectionPromise;
  layoutXS: (where: LayoutXSWhereUniqueInput) => LayoutXSNullablePromise;
  layoutXses: (args?: {
    where?: LayoutXSWhereInput;
    orderBy?: LayoutXSOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LayoutXS>;
  layoutXsesConnection: (args?: {
    where?: LayoutXSWhereInput;
    orderBy?: LayoutXSOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LayoutXSConnectionPromise;
  month: (where: MonthWhereUniqueInput) => MonthNullablePromise;
  months: (args?: {
    where?: MonthWhereInput;
    orderBy?: MonthOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Month>;
  monthsConnection: (args?: {
    where?: MonthWhereInput;
    orderBy?: MonthOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MonthConnectionPromise;
  quarter: (where: QuarterWhereUniqueInput) => QuarterNullablePromise;
  quarters: (args?: {
    where?: QuarterWhereInput;
    orderBy?: QuarterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Quarter>;
  quartersConnection: (args?: {
    where?: QuarterWhereInput;
    orderBy?: QuarterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuarterConnectionPromise;
  week: (where: WeekWhereUniqueInput) => WeekNullablePromise;
  weeks: (args?: {
    where?: WeekWhereInput;
    orderBy?: WeekOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Week>;
  weeksConnection: (args?: {
    where?: WeekWhereInput;
    orderBy?: WeekOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WeekConnectionPromise;
  year: (where: YearWhereUniqueInput) => YearNullablePromise;
  years: (args?: {
    where?: YearWhereInput;
    orderBy?: YearOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Year>;
  yearsConnection: (args?: {
    where?: YearWhereInput;
    orderBy?: YearOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => YearConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCard: (data: CardCreateInput) => CardPromise;
  updateCard: (args: {
    data: CardUpdateInput;
    where: CardWhereUniqueInput;
  }) => CardPromise;
  updateManyCards: (args: {
    data: CardUpdateManyMutationInput;
    where?: CardWhereInput;
  }) => BatchPayloadPromise;
  upsertCard: (args: {
    where: CardWhereUniqueInput;
    create: CardCreateInput;
    update: CardUpdateInput;
  }) => CardPromise;
  deleteCard: (where: CardWhereUniqueInput) => CardPromise;
  deleteManyCards: (where?: CardWhereInput) => BatchPayloadPromise;
  createDashboard: (data: DashboardCreateInput) => DashboardPromise;
  updateDashboard: (args: {
    data: DashboardUpdateInput;
    where: DashboardWhereUniqueInput;
  }) => DashboardPromise;
  updateManyDashboards: (args: {
    data: DashboardUpdateManyMutationInput;
    where?: DashboardWhereInput;
  }) => BatchPayloadPromise;
  upsertDashboard: (args: {
    where: DashboardWhereUniqueInput;
    create: DashboardCreateInput;
    update: DashboardUpdateInput;
  }) => DashboardPromise;
  deleteDashboard: (where: DashboardWhereUniqueInput) => DashboardPromise;
  deleteManyDashboards: (where?: DashboardWhereInput) => BatchPayloadPromise;
  createDay: (data: DayCreateInput) => DayPromise;
  updateDay: (args: {
    data: DayUpdateInput;
    where: DayWhereUniqueInput;
  }) => DayPromise;
  updateManyDays: (args: {
    data: DayUpdateManyMutationInput;
    where?: DayWhereInput;
  }) => BatchPayloadPromise;
  upsertDay: (args: {
    where: DayWhereUniqueInput;
    create: DayCreateInput;
    update: DayUpdateInput;
  }) => DayPromise;
  deleteDay: (where: DayWhereUniqueInput) => DayPromise;
  deleteManyDays: (where?: DayWhereInput) => BatchPayloadPromise;
  createEntity: (data: EntityCreateInput) => EntityPromise;
  updateEntity: (args: {
    data: EntityUpdateInput;
    where: EntityWhereUniqueInput;
  }) => EntityPromise;
  updateManyEntities: (args: {
    data: EntityUpdateManyMutationInput;
    where?: EntityWhereInput;
  }) => BatchPayloadPromise;
  upsertEntity: (args: {
    where: EntityWhereUniqueInput;
    create: EntityCreateInput;
    update: EntityUpdateInput;
  }) => EntityPromise;
  deleteEntity: (where: EntityWhereUniqueInput) => EntityPromise;
  deleteManyEntities: (where?: EntityWhereInput) => BatchPayloadPromise;
  createGrouping: (data: GroupingCreateInput) => GroupingPromise;
  updateGrouping: (args: {
    data: GroupingUpdateInput;
    where: GroupingWhereUniqueInput;
  }) => GroupingPromise;
  updateManyGroupings: (args: {
    data: GroupingUpdateManyMutationInput;
    where?: GroupingWhereInput;
  }) => BatchPayloadPromise;
  upsertGrouping: (args: {
    where: GroupingWhereUniqueInput;
    create: GroupingCreateInput;
    update: GroupingUpdateInput;
  }) => GroupingPromise;
  deleteGrouping: (where: GroupingWhereUniqueInput) => GroupingPromise;
  deleteManyGroupings: (where?: GroupingWhereInput) => BatchPayloadPromise;
  createHour: (data: HourCreateInput) => HourPromise;
  updateHour: (args: {
    data: HourUpdateInput;
    where: HourWhereUniqueInput;
  }) => HourPromise;
  updateManyHours: (args: {
    data: HourUpdateManyMutationInput;
    where?: HourWhereInput;
  }) => BatchPayloadPromise;
  upsertHour: (args: {
    where: HourWhereUniqueInput;
    create: HourCreateInput;
    update: HourUpdateInput;
  }) => HourPromise;
  deleteHour: (where: HourWhereUniqueInput) => HourPromise;
  deleteManyHours: (where?: HourWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createLayoutLG: (data: LayoutLGCreateInput) => LayoutLGPromise;
  updateLayoutLG: (args: {
    data: LayoutLGUpdateInput;
    where: LayoutLGWhereUniqueInput;
  }) => LayoutLGPromise;
  updateManyLayoutLGs: (args: {
    data: LayoutLGUpdateManyMutationInput;
    where?: LayoutLGWhereInput;
  }) => BatchPayloadPromise;
  upsertLayoutLG: (args: {
    where: LayoutLGWhereUniqueInput;
    create: LayoutLGCreateInput;
    update: LayoutLGUpdateInput;
  }) => LayoutLGPromise;
  deleteLayoutLG: (where: LayoutLGWhereUniqueInput) => LayoutLGPromise;
  deleteManyLayoutLGs: (where?: LayoutLGWhereInput) => BatchPayloadPromise;
  createLayoutMD: (data: LayoutMDCreateInput) => LayoutMDPromise;
  updateLayoutMD: (args: {
    data: LayoutMDUpdateInput;
    where: LayoutMDWhereUniqueInput;
  }) => LayoutMDPromise;
  updateManyLayoutMDs: (args: {
    data: LayoutMDUpdateManyMutationInput;
    where?: LayoutMDWhereInput;
  }) => BatchPayloadPromise;
  upsertLayoutMD: (args: {
    where: LayoutMDWhereUniqueInput;
    create: LayoutMDCreateInput;
    update: LayoutMDUpdateInput;
  }) => LayoutMDPromise;
  deleteLayoutMD: (where: LayoutMDWhereUniqueInput) => LayoutMDPromise;
  deleteManyLayoutMDs: (where?: LayoutMDWhereInput) => BatchPayloadPromise;
  createLayoutSM: (data: LayoutSMCreateInput) => LayoutSMPromise;
  updateLayoutSM: (args: {
    data: LayoutSMUpdateInput;
    where: LayoutSMWhereUniqueInput;
  }) => LayoutSMPromise;
  updateManyLayoutSMs: (args: {
    data: LayoutSMUpdateManyMutationInput;
    where?: LayoutSMWhereInput;
  }) => BatchPayloadPromise;
  upsertLayoutSM: (args: {
    where: LayoutSMWhereUniqueInput;
    create: LayoutSMCreateInput;
    update: LayoutSMUpdateInput;
  }) => LayoutSMPromise;
  deleteLayoutSM: (where: LayoutSMWhereUniqueInput) => LayoutSMPromise;
  deleteManyLayoutSMs: (where?: LayoutSMWhereInput) => BatchPayloadPromise;
  createLayoutXS: (data: LayoutXSCreateInput) => LayoutXSPromise;
  updateLayoutXS: (args: {
    data: LayoutXSUpdateInput;
    where: LayoutXSWhereUniqueInput;
  }) => LayoutXSPromise;
  updateManyLayoutXses: (args: {
    data: LayoutXSUpdateManyMutationInput;
    where?: LayoutXSWhereInput;
  }) => BatchPayloadPromise;
  upsertLayoutXS: (args: {
    where: LayoutXSWhereUniqueInput;
    create: LayoutXSCreateInput;
    update: LayoutXSUpdateInput;
  }) => LayoutXSPromise;
  deleteLayoutXS: (where: LayoutXSWhereUniqueInput) => LayoutXSPromise;
  deleteManyLayoutXses: (where?: LayoutXSWhereInput) => BatchPayloadPromise;
  createMonth: (data: MonthCreateInput) => MonthPromise;
  updateMonth: (args: {
    data: MonthUpdateInput;
    where: MonthWhereUniqueInput;
  }) => MonthPromise;
  updateManyMonths: (args: {
    data: MonthUpdateManyMutationInput;
    where?: MonthWhereInput;
  }) => BatchPayloadPromise;
  upsertMonth: (args: {
    where: MonthWhereUniqueInput;
    create: MonthCreateInput;
    update: MonthUpdateInput;
  }) => MonthPromise;
  deleteMonth: (where: MonthWhereUniqueInput) => MonthPromise;
  deleteManyMonths: (where?: MonthWhereInput) => BatchPayloadPromise;
  createQuarter: (data: QuarterCreateInput) => QuarterPromise;
  updateQuarter: (args: {
    data: QuarterUpdateInput;
    where: QuarterWhereUniqueInput;
  }) => QuarterPromise;
  updateManyQuarters: (args: {
    data: QuarterUpdateManyMutationInput;
    where?: QuarterWhereInput;
  }) => BatchPayloadPromise;
  upsertQuarter: (args: {
    where: QuarterWhereUniqueInput;
    create: QuarterCreateInput;
    update: QuarterUpdateInput;
  }) => QuarterPromise;
  deleteQuarter: (where: QuarterWhereUniqueInput) => QuarterPromise;
  deleteManyQuarters: (where?: QuarterWhereInput) => BatchPayloadPromise;
  createWeek: (data: WeekCreateInput) => WeekPromise;
  updateWeek: (args: {
    data: WeekUpdateInput;
    where: WeekWhereUniqueInput;
  }) => WeekPromise;
  updateManyWeeks: (args: {
    data: WeekUpdateManyMutationInput;
    where?: WeekWhereInput;
  }) => BatchPayloadPromise;
  upsertWeek: (args: {
    where: WeekWhereUniqueInput;
    create: WeekCreateInput;
    update: WeekUpdateInput;
  }) => WeekPromise;
  deleteWeek: (where: WeekWhereUniqueInput) => WeekPromise;
  deleteManyWeeks: (where?: WeekWhereInput) => BatchPayloadPromise;
  createYear: (data: YearCreateInput) => YearPromise;
  updateYear: (args: {
    data: YearUpdateInput;
    where: YearWhereUniqueInput;
  }) => YearPromise;
  updateManyYears: (args: {
    data: YearUpdateManyMutationInput;
    where?: YearWhereInput;
  }) => BatchPayloadPromise;
  upsertYear: (args: {
    where: YearWhereUniqueInput;
    create: YearCreateInput;
    update: YearUpdateInput;
  }) => YearPromise;
  deleteYear: (where: YearWhereUniqueInput) => YearPromise;
  deleteManyYears: (where?: YearWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  card: (
    where?: CardSubscriptionWhereInput
  ) => CardSubscriptionPayloadSubscription;
  dashboard: (
    where?: DashboardSubscriptionWhereInput
  ) => DashboardSubscriptionPayloadSubscription;
  day: (
    where?: DaySubscriptionWhereInput
  ) => DaySubscriptionPayloadSubscription;
  entity: (
    where?: EntitySubscriptionWhereInput
  ) => EntitySubscriptionPayloadSubscription;
  grouping: (
    where?: GroupingSubscriptionWhereInput
  ) => GroupingSubscriptionPayloadSubscription;
  hour: (
    where?: HourSubscriptionWhereInput
  ) => HourSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  layoutLG: (
    where?: LayoutLGSubscriptionWhereInput
  ) => LayoutLGSubscriptionPayloadSubscription;
  layoutMD: (
    where?: LayoutMDSubscriptionWhereInput
  ) => LayoutMDSubscriptionPayloadSubscription;
  layoutSM: (
    where?: LayoutSMSubscriptionWhereInput
  ) => LayoutSMSubscriptionPayloadSubscription;
  layoutXS: (
    where?: LayoutXSSubscriptionWhereInput
  ) => LayoutXSSubscriptionPayloadSubscription;
  month: (
    where?: MonthSubscriptionWhereInput
  ) => MonthSubscriptionPayloadSubscription;
  quarter: (
    where?: QuarterSubscriptionWhereInput
  ) => QuarterSubscriptionPayloadSubscription;
  week: (
    where?: WeekSubscriptionWhereInput
  ) => WeekSubscriptionPayloadSubscription;
  year: (
    where?: YearSubscriptionWhereInput
  ) => YearSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Source = "ORION" | "SPLUNK" | "OTHER";

export type LayoutXSOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "x_ASC"
  | "x_DESC"
  | "y_ASC"
  | "y_DESC"
  | "w_ASC"
  | "w_DESC"
  | "h_ASC"
  | "h_DESC";

export type Level =
  | "CRITICAL"
  | "INFORMATIONAL"
  | "NOTICE"
  | "SERIOUS"
  | "WARNING"
  | "ALERT"
  | "EMERGENCY"
  | "ERROR"
  | "UNKNOWN";

export type YearOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC";

export type ItemType =
  | "ALERT"
  | "TRAP"
  | "SYSLOG"
  | "WINDOWSEVENT"
  | "VMWAREEVENT"
  | "UNKNOWN";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "alertID_ASC"
  | "alertID_DESC"
  | "logID_ASC"
  | "logID_DESC"
  | "triggerTime_ASC"
  | "triggerTime_DESC"
  | "name_ASC"
  | "name_DESC"
  | "message_ASC"
  | "message_DESC"
  | "level_ASC"
  | "level_DESC"
  | "source_ASC"
  | "source_DESC";

export type GroupingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "subtitle_ASC"
  | "subtitle_DESC";

export type WeekOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "weekYear_ASC"
  | "weekYear_DESC";

export type CardOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "cardType_ASC"
  | "cardType_DESC"
  | "title_ASC"
  | "title_DESC";

export type DayOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "dayMonthYear_ASC"
  | "dayMonthYear_DESC";

export type LayoutLGOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "x_ASC"
  | "x_DESC"
  | "y_ASC"
  | "y_DESC"
  | "w_ASC"
  | "w_DESC"
  | "h_ASC"
  | "h_DESC";

export type EntityType = "NODE" | "INTERFACE";

export type DashboardOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type LayoutSMOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "x_ASC"
  | "x_DESC"
  | "y_ASC"
  | "y_DESC"
  | "w_ASC"
  | "w_DESC"
  | "h_ASC"
  | "h_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type LayoutMDOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "x_ASC"
  | "x_DESC"
  | "y_ASC"
  | "y_DESC"
  | "w_ASC"
  | "w_DESC"
  | "h_ASC"
  | "h_DESC";

export type CardType =
  | "MONTHBAR"
  | "WEEKDENSITY"
  | "WEEKBAR"
  | "FILTER"
  | "TRIGGERLIST"
  | "STACKEDSEVERITY";

export type QuarterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "quarterYear_ASC"
  | "quarterYear_DESC";

export type MonthOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "monthYear_ASC"
  | "monthYear_DESC";

export type HourOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "hourDayMonthYear_ASC"
  | "hourDayMonthYear_DESC";

export type EntityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "entityID_ASC"
  | "entityID_DESC"
  | "name_ASC"
  | "name_DESC"
  | "linkForEntity_ASC"
  | "linkForEntity_DESC"
  | "type_ASC"
  | "type_DESC"
  | "source_ASC"
  | "source_DESC";

export interface GroupingUpdateOneRequiredWithoutLayoutXSsInput {
  create?: Maybe<GroupingCreateWithoutLayoutXSsInput>;
  update?: Maybe<GroupingUpdateWithoutLayoutXSsDataInput>;
  upsert?: Maybe<GroupingUpsertWithoutLayoutXSsInput>;
  connect?: Maybe<GroupingWhereUniqueInput>;
}

export interface YearUpsertWithoutQuartersInput {
  update: YearUpdateWithoutQuartersDataInput;
  create: YearCreateWithoutQuartersInput;
}

export interface CardUpdateOneRequiredWithoutLayoutXSInput {
  create?: Maybe<CardCreateWithoutLayoutXSInput>;
  update?: Maybe<CardUpdateWithoutLayoutXSDataInput>;
  upsert?: Maybe<CardUpsertWithoutLayoutXSInput>;
  connect?: Maybe<CardWhereUniqueInput>;
}

export type CardWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CardUpdateWithoutLayoutXSDataInput {
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutLG?: Maybe<LayoutLGUpdateOneRequiredWithoutCardInput>;
  layoutMD?: Maybe<LayoutMDUpdateOneRequiredWithoutCardInput>;
  layoutSM?: Maybe<LayoutSMUpdateOneRequiredWithoutCardInput>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutCardsInput>;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface CardUpsertWithoutLayoutXSInput {
  update: CardUpdateWithoutLayoutXSDataInput;
  create: CardCreateWithoutLayoutXSInput;
}

export interface GroupingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GroupingWhereInput>;
  AND?: Maybe<
    GroupingSubscriptionWhereInput[] | GroupingSubscriptionWhereInput
  >;
  OR?: Maybe<GroupingSubscriptionWhereInput[] | GroupingSubscriptionWhereInput>;
  NOT?: Maybe<
    GroupingSubscriptionWhereInput[] | GroupingSubscriptionWhereInput
  >;
}

export interface LayoutXSUpsertWithWhereUniqueWithoutGroupingInput {
  where: LayoutXSWhereUniqueInput;
  update: LayoutXSUpdateWithoutGroupingDataInput;
  create: LayoutXSCreateWithoutGroupingInput;
}

export interface DaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DayWhereInput>;
  AND?: Maybe<DaySubscriptionWhereInput[] | DaySubscriptionWhereInput>;
  OR?: Maybe<DaySubscriptionWhereInput[] | DaySubscriptionWhereInput>;
  NOT?: Maybe<DaySubscriptionWhereInput[] | DaySubscriptionWhereInput>;
}

export interface LayoutXSScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  w?: Maybe<Int>;
  w_not?: Maybe<Int>;
  w_in?: Maybe<Int[] | Int>;
  w_not_in?: Maybe<Int[] | Int>;
  w_lt?: Maybe<Int>;
  w_lte?: Maybe<Int>;
  w_gt?: Maybe<Int>;
  w_gte?: Maybe<Int>;
  h?: Maybe<Int>;
  h_not?: Maybe<Int>;
  h_in?: Maybe<Int[] | Int>;
  h_not_in?: Maybe<Int[] | Int>;
  h_lt?: Maybe<Int>;
  h_lte?: Maybe<Int>;
  h_gt?: Maybe<Int>;
  h_gte?: Maybe<Int>;
  AND?: Maybe<LayoutXSScalarWhereInput[] | LayoutXSScalarWhereInput>;
  OR?: Maybe<LayoutXSScalarWhereInput[] | LayoutXSScalarWhereInput>;
  NOT?: Maybe<LayoutXSScalarWhereInput[] | LayoutXSScalarWhereInput>;
}

export type DashboardWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface LayoutXSUpdateManyWithWhereNestedInput {
  where: LayoutXSScalarWhereInput;
  data: LayoutXSUpdateManyDataInput;
}

export interface LayoutMDSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LayoutMDWhereInput>;
  AND?: Maybe<
    LayoutMDSubscriptionWhereInput[] | LayoutMDSubscriptionWhereInput
  >;
  OR?: Maybe<LayoutMDSubscriptionWhereInput[] | LayoutMDSubscriptionWhereInput>;
  NOT?: Maybe<
    LayoutMDSubscriptionWhereInput[] | LayoutMDSubscriptionWhereInput
  >;
}

export interface LayoutXSUpdateManyDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
}

export interface YearUpdateManyMutationInput {
  value?: Maybe<Int>;
}

export interface GroupingUpsertWithoutCardsInput {
  update: GroupingUpdateWithoutCardsDataInput;
  create: GroupingCreateWithoutCardsInput;
}

export interface YearUpdateInput {
  value?: Maybe<Int>;
  quarters?: Maybe<QuarterUpdateManyWithoutYearInput>;
  months?: Maybe<MonthUpdateManyWithoutYearInput>;
  weeks?: Maybe<WeekUpdateManyWithoutYearInput>;
}

export interface CardUpsertWithoutLayoutSMInput {
  update: CardUpdateWithoutLayoutSMDataInput;
  create: CardCreateWithoutLayoutSMInput;
}

export interface QuarterWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  quarterYear?: Maybe<String>;
  quarterYear_not?: Maybe<String>;
  quarterYear_in?: Maybe<String[] | String>;
  quarterYear_not_in?: Maybe<String[] | String>;
  quarterYear_lt?: Maybe<String>;
  quarterYear_lte?: Maybe<String>;
  quarterYear_gt?: Maybe<String>;
  quarterYear_gte?: Maybe<String>;
  quarterYear_contains?: Maybe<String>;
  quarterYear_not_contains?: Maybe<String>;
  quarterYear_starts_with?: Maybe<String>;
  quarterYear_not_starts_with?: Maybe<String>;
  quarterYear_ends_with?: Maybe<String>;
  quarterYear_not_ends_with?: Maybe<String>;
  year?: Maybe<YearWhereInput>;
  days_every?: Maybe<DayWhereInput>;
  days_some?: Maybe<DayWhereInput>;
  days_none?: Maybe<DayWhereInput>;
  AND?: Maybe<QuarterWhereInput[] | QuarterWhereInput>;
  OR?: Maybe<QuarterWhereInput[] | QuarterWhereInput>;
  NOT?: Maybe<QuarterWhereInput[] | QuarterWhereInput>;
}

export interface LayoutSMUpsertWithWhereUniqueWithoutGroupingInput {
  where: LayoutSMWhereUniqueInput;
  update: LayoutSMUpdateWithoutGroupingDataInput;
  create: LayoutSMCreateWithoutGroupingInput;
}

export interface MonthWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  monthYear?: Maybe<String>;
  monthYear_not?: Maybe<String>;
  monthYear_in?: Maybe<String[] | String>;
  monthYear_not_in?: Maybe<String[] | String>;
  monthYear_lt?: Maybe<String>;
  monthYear_lte?: Maybe<String>;
  monthYear_gt?: Maybe<String>;
  monthYear_gte?: Maybe<String>;
  monthYear_contains?: Maybe<String>;
  monthYear_not_contains?: Maybe<String>;
  monthYear_starts_with?: Maybe<String>;
  monthYear_not_starts_with?: Maybe<String>;
  monthYear_ends_with?: Maybe<String>;
  monthYear_not_ends_with?: Maybe<String>;
  year?: Maybe<YearWhereInput>;
  days_every?: Maybe<DayWhereInput>;
  days_some?: Maybe<DayWhereInput>;
  days_none?: Maybe<DayWhereInput>;
  AND?: Maybe<MonthWhereInput[] | MonthWhereInput>;
  OR?: Maybe<MonthWhereInput[] | MonthWhereInput>;
  NOT?: Maybe<MonthWhereInput[] | MonthWhereInput>;
}

export interface LayoutSMScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  w?: Maybe<Int>;
  w_not?: Maybe<Int>;
  w_in?: Maybe<Int[] | Int>;
  w_not_in?: Maybe<Int[] | Int>;
  w_lt?: Maybe<Int>;
  w_lte?: Maybe<Int>;
  w_gt?: Maybe<Int>;
  w_gte?: Maybe<Int>;
  h?: Maybe<Int>;
  h_not?: Maybe<Int>;
  h_in?: Maybe<Int[] | Int>;
  h_not_in?: Maybe<Int[] | Int>;
  h_lt?: Maybe<Int>;
  h_lte?: Maybe<Int>;
  h_gt?: Maybe<Int>;
  h_gte?: Maybe<Int>;
  AND?: Maybe<LayoutSMScalarWhereInput[] | LayoutSMScalarWhereInput>;
  OR?: Maybe<LayoutSMScalarWhereInput[] | LayoutSMScalarWhereInput>;
  NOT?: Maybe<LayoutSMScalarWhereInput[] | LayoutSMScalarWhereInput>;
}

export interface WeekWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  weekYear?: Maybe<String>;
  weekYear_not?: Maybe<String>;
  weekYear_in?: Maybe<String[] | String>;
  weekYear_not_in?: Maybe<String[] | String>;
  weekYear_lt?: Maybe<String>;
  weekYear_lte?: Maybe<String>;
  weekYear_gt?: Maybe<String>;
  weekYear_gte?: Maybe<String>;
  weekYear_contains?: Maybe<String>;
  weekYear_not_contains?: Maybe<String>;
  weekYear_starts_with?: Maybe<String>;
  weekYear_not_starts_with?: Maybe<String>;
  weekYear_ends_with?: Maybe<String>;
  weekYear_not_ends_with?: Maybe<String>;
  year?: Maybe<YearWhereInput>;
  days_every?: Maybe<DayWhereInput>;
  days_some?: Maybe<DayWhereInput>;
  days_none?: Maybe<DayWhereInput>;
  AND?: Maybe<WeekWhereInput[] | WeekWhereInput>;
  OR?: Maybe<WeekWhereInput[] | WeekWhereInput>;
  NOT?: Maybe<WeekWhereInput[] | WeekWhereInput>;
}

export interface LayoutSMUpdateManyWithWhereNestedInput {
  where: LayoutSMScalarWhereInput;
  data: LayoutSMUpdateManyDataInput;
}

export interface ItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<ItemType>;
  type_not?: Maybe<ItemType>;
  type_in?: Maybe<ItemType[] | ItemType>;
  type_not_in?: Maybe<ItemType[] | ItemType>;
  alertID?: Maybe<Int>;
  alertID_not?: Maybe<Int>;
  alertID_in?: Maybe<Int[] | Int>;
  alertID_not_in?: Maybe<Int[] | Int>;
  alertID_lt?: Maybe<Int>;
  alertID_lte?: Maybe<Int>;
  alertID_gt?: Maybe<Int>;
  alertID_gte?: Maybe<Int>;
  logID?: Maybe<String>;
  logID_not?: Maybe<String>;
  logID_in?: Maybe<String[] | String>;
  logID_not_in?: Maybe<String[] | String>;
  logID_lt?: Maybe<String>;
  logID_lte?: Maybe<String>;
  logID_gt?: Maybe<String>;
  logID_gte?: Maybe<String>;
  logID_contains?: Maybe<String>;
  logID_not_contains?: Maybe<String>;
  logID_starts_with?: Maybe<String>;
  logID_not_starts_with?: Maybe<String>;
  logID_ends_with?: Maybe<String>;
  logID_not_ends_with?: Maybe<String>;
  triggerTime?: Maybe<String>;
  triggerTime_not?: Maybe<String>;
  triggerTime_in?: Maybe<String[] | String>;
  triggerTime_not_in?: Maybe<String[] | String>;
  triggerTime_lt?: Maybe<String>;
  triggerTime_lte?: Maybe<String>;
  triggerTime_gt?: Maybe<String>;
  triggerTime_gte?: Maybe<String>;
  triggerTime_contains?: Maybe<String>;
  triggerTime_not_contains?: Maybe<String>;
  triggerTime_starts_with?: Maybe<String>;
  triggerTime_not_starts_with?: Maybe<String>;
  triggerTime_ends_with?: Maybe<String>;
  triggerTime_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  level?: Maybe<Level>;
  level_not?: Maybe<Level>;
  level_in?: Maybe<Level[] | Level>;
  level_not_in?: Maybe<Level[] | Level>;
  source?: Maybe<Source>;
  source_not?: Maybe<Source>;
  source_in?: Maybe<Source[] | Source>;
  source_not_in?: Maybe<Source[] | Source>;
  trigger?: Maybe<EntityWhereInput>;
  hour?: Maybe<HourWhereInput>;
  day?: Maybe<DayWhereInput>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface LayoutSMUpdateManyDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
}

export interface LayoutSMWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  w?: Maybe<Int>;
  w_not?: Maybe<Int>;
  w_in?: Maybe<Int[] | Int>;
  w_not_in?: Maybe<Int[] | Int>;
  w_lt?: Maybe<Int>;
  w_lte?: Maybe<Int>;
  w_gt?: Maybe<Int>;
  w_gte?: Maybe<Int>;
  h?: Maybe<Int>;
  h_not?: Maybe<Int>;
  h_in?: Maybe<Int[] | Int>;
  h_not_in?: Maybe<Int[] | Int>;
  h_lt?: Maybe<Int>;
  h_lte?: Maybe<Int>;
  h_gt?: Maybe<Int>;
  h_gte?: Maybe<Int>;
  card?: Maybe<CardWhereInput>;
  grouping?: Maybe<GroupingWhereInput>;
  AND?: Maybe<LayoutSMWhereInput[] | LayoutSMWhereInput>;
  OR?: Maybe<LayoutSMWhereInput[] | LayoutSMWhereInput>;
  NOT?: Maybe<LayoutSMWhereInput[] | LayoutSMWhereInput>;
}

export interface GroupingUpsertWithoutLayoutXSsInput {
  update: GroupingUpdateWithoutLayoutXSsDataInput;
  create: GroupingCreateWithoutLayoutXSsInput;
}

export interface EntityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  entityID?: Maybe<String>;
  entityID_not?: Maybe<String>;
  entityID_in?: Maybe<String[] | String>;
  entityID_not_in?: Maybe<String[] | String>;
  entityID_lt?: Maybe<String>;
  entityID_lte?: Maybe<String>;
  entityID_gt?: Maybe<String>;
  entityID_gte?: Maybe<String>;
  entityID_contains?: Maybe<String>;
  entityID_not_contains?: Maybe<String>;
  entityID_starts_with?: Maybe<String>;
  entityID_not_starts_with?: Maybe<String>;
  entityID_ends_with?: Maybe<String>;
  entityID_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  linkForEntity?: Maybe<String>;
  linkForEntity_not?: Maybe<String>;
  linkForEntity_in?: Maybe<String[] | String>;
  linkForEntity_not_in?: Maybe<String[] | String>;
  linkForEntity_lt?: Maybe<String>;
  linkForEntity_lte?: Maybe<String>;
  linkForEntity_gt?: Maybe<String>;
  linkForEntity_gte?: Maybe<String>;
  linkForEntity_contains?: Maybe<String>;
  linkForEntity_not_contains?: Maybe<String>;
  linkForEntity_starts_with?: Maybe<String>;
  linkForEntity_not_starts_with?: Maybe<String>;
  linkForEntity_ends_with?: Maybe<String>;
  linkForEntity_not_ends_with?: Maybe<String>;
  type?: Maybe<EntityType>;
  type_not?: Maybe<EntityType>;
  type_in?: Maybe<EntityType[] | EntityType>;
  type_not_in?: Maybe<EntityType[] | EntityType>;
  source?: Maybe<Source>;
  source_not?: Maybe<Source>;
  source_in?: Maybe<Source[] | Source>;
  source_not_in?: Maybe<Source[] | Source>;
  parent?: Maybe<EntityWhereInput>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  AND?: Maybe<EntityWhereInput[] | EntityWhereInput>;
  OR?: Maybe<EntityWhereInput[] | EntityWhereInput>;
  NOT?: Maybe<EntityWhereInput[] | EntityWhereInput>;
}

export interface LayoutXSUpsertWithoutCardInput {
  update: LayoutXSUpdateWithoutCardDataInput;
  create: LayoutXSCreateWithoutCardInput;
}

export interface CardWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  cardType?: Maybe<CardType>;
  cardType_not?: Maybe<CardType>;
  cardType_in?: Maybe<CardType[] | CardType>;
  cardType_not_in?: Maybe<CardType[] | CardType>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  layoutLG?: Maybe<LayoutLGWhereInput>;
  layoutMD?: Maybe<LayoutMDWhereInput>;
  layoutSM?: Maybe<LayoutSMWhereInput>;
  layoutXS?: Maybe<LayoutXSWhereInput>;
  grouping?: Maybe<GroupingWhereInput>;
  AND?: Maybe<CardWhereInput[] | CardWhereInput>;
  OR?: Maybe<CardWhereInput[] | CardWhereInput>;
  NOT?: Maybe<CardWhereInput[] | CardWhereInput>;
}

export interface CardUpsertWithoutLayoutMDInput {
  update: CardUpdateWithoutLayoutMDDataInput;
  create: CardCreateWithoutLayoutMDInput;
}

export interface DashboardWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  groupings_every?: Maybe<GroupingWhereInput>;
  groupings_some?: Maybe<GroupingWhereInput>;
  groupings_none?: Maybe<GroupingWhereInput>;
  AND?: Maybe<DashboardWhereInput[] | DashboardWhereInput>;
  OR?: Maybe<DashboardWhereInput[] | DashboardWhereInput>;
  NOT?: Maybe<DashboardWhereInput[] | DashboardWhereInput>;
}

export interface LayoutMDUpsertWithWhereUniqueWithoutGroupingInput {
  where: LayoutMDWhereUniqueInput;
  update: LayoutMDUpdateWithoutGroupingDataInput;
  create: LayoutMDCreateWithoutGroupingInput;
}

export interface WeekCreateInput {
  id?: Maybe<ID_Input>;
  value: Int;
  weekYear: String;
  year: YearCreateOneWithoutWeeksInput;
  days?: Maybe<DayCreateManyWithoutWeekInput>;
}

export interface LayoutMDScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  w?: Maybe<Int>;
  w_not?: Maybe<Int>;
  w_in?: Maybe<Int[] | Int>;
  w_not_in?: Maybe<Int[] | Int>;
  w_lt?: Maybe<Int>;
  w_lte?: Maybe<Int>;
  w_gt?: Maybe<Int>;
  w_gte?: Maybe<Int>;
  h?: Maybe<Int>;
  h_not?: Maybe<Int>;
  h_in?: Maybe<Int[] | Int>;
  h_not_in?: Maybe<Int[] | Int>;
  h_lt?: Maybe<Int>;
  h_lte?: Maybe<Int>;
  h_gt?: Maybe<Int>;
  h_gte?: Maybe<Int>;
  AND?: Maybe<LayoutMDScalarWhereInput[] | LayoutMDScalarWhereInput>;
  OR?: Maybe<LayoutMDScalarWhereInput[] | LayoutMDScalarWhereInput>;
  NOT?: Maybe<LayoutMDScalarWhereInput[] | LayoutMDScalarWhereInput>;
}

export interface QuarterUpdateManyMutationInput {
  value?: Maybe<Int>;
  quarterYear?: Maybe<String>;
}

export interface LayoutMDUpdateManyWithWhereNestedInput {
  where: LayoutMDScalarWhereInput;
  data: LayoutMDUpdateManyDataInput;
}

export interface QuarterUpdateInput {
  value?: Maybe<Int>;
  quarterYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredWithoutQuartersInput>;
  days?: Maybe<DayUpdateManyWithoutQuarterInput>;
}

export interface LayoutMDUpdateManyDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
}

export interface QuarterCreateInput {
  id?: Maybe<ID_Input>;
  value: Int;
  quarterYear: String;
  year: YearCreateOneWithoutQuartersInput;
  days?: Maybe<DayCreateManyWithoutQuarterInput>;
}

export interface GroupingUpsertWithoutLayoutSMsInput {
  update: GroupingUpdateWithoutLayoutSMsDataInput;
  create: GroupingCreateWithoutLayoutSMsInput;
}

export interface MonthUpdateInput {
  value?: Maybe<Int>;
  monthYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredWithoutMonthsInput>;
  days?: Maybe<DayUpdateManyWithoutMonthInput>;
}

export interface LayoutSMUpsertWithoutCardInput {
  update: LayoutSMUpdateWithoutCardDataInput;
  create: LayoutSMCreateWithoutCardInput;
}

export interface LayoutXSUpdateManyMutationInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
}

export interface CardUpsertWithoutLayoutLGInput {
  update: CardUpdateWithoutLayoutLGDataInput;
  create: CardCreateWithoutLayoutLGInput;
}

export interface QuarterSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuarterWhereInput>;
  AND?: Maybe<QuarterSubscriptionWhereInput[] | QuarterSubscriptionWhereInput>;
  OR?: Maybe<QuarterSubscriptionWhereInput[] | QuarterSubscriptionWhereInput>;
  NOT?: Maybe<QuarterSubscriptionWhereInput[] | QuarterSubscriptionWhereInput>;
}

export interface LayoutLGUpsertWithWhereUniqueWithoutGroupingInput {
  where: LayoutLGWhereUniqueInput;
  update: LayoutLGUpdateWithoutGroupingDataInput;
  create: LayoutLGCreateWithoutGroupingInput;
}

export interface LayoutXSCreateInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  card: CardCreateOneWithoutLayoutXSInput;
  grouping: GroupingCreateOneWithoutLayoutXSsInput;
}

export interface LayoutLGScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  w?: Maybe<Int>;
  w_not?: Maybe<Int>;
  w_in?: Maybe<Int[] | Int>;
  w_not_in?: Maybe<Int[] | Int>;
  w_lt?: Maybe<Int>;
  w_lte?: Maybe<Int>;
  w_gt?: Maybe<Int>;
  w_gte?: Maybe<Int>;
  h?: Maybe<Int>;
  h_not?: Maybe<Int>;
  h_in?: Maybe<Int[] | Int>;
  h_not_in?: Maybe<Int[] | Int>;
  h_lt?: Maybe<Int>;
  h_lte?: Maybe<Int>;
  h_gt?: Maybe<Int>;
  h_gte?: Maybe<Int>;
  AND?: Maybe<LayoutLGScalarWhereInput[] | LayoutLGScalarWhereInput>;
  OR?: Maybe<LayoutLGScalarWhereInput[] | LayoutLGScalarWhereInput>;
  NOT?: Maybe<LayoutLGScalarWhereInput[] | LayoutLGScalarWhereInput>;
}

export type GroupingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LayoutLGUpdateManyWithWhereNestedInput {
  where: LayoutLGScalarWhereInput;
  data: LayoutLGUpdateManyDataInput;
}

export interface LayoutSMCreateInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  card: CardCreateOneWithoutLayoutSMInput;
  grouping: GroupingCreateOneWithoutLayoutSMsInput;
}

export interface LayoutLGUpdateManyDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
}

export type HourWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  hourDayMonthYear?: Maybe<String>;
}>;

export interface GroupingUpsertWithoutLayoutMDsInput {
  update: GroupingUpdateWithoutLayoutMDsDataInput;
  create: GroupingCreateWithoutLayoutMDsInput;
}

export interface LayoutMDCreateInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  card: CardCreateOneWithoutLayoutMDInput;
  grouping: GroupingCreateOneWithoutLayoutMDsInput;
}

export interface LayoutMDUpsertWithoutCardInput {
  update: LayoutMDUpdateWithoutCardDataInput;
  create: LayoutMDCreateWithoutCardInput;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  alertID?: Maybe<Int>;
  logID?: Maybe<String>;
}>;

export interface CardUpsertWithWhereUniqueWithoutGroupingInput {
  where: CardWhereUniqueInput;
  update: CardUpdateWithoutGroupingDataInput;
  create: CardCreateWithoutGroupingInput;
}

export interface LayoutLGCreateInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  card: CardCreateOneWithoutLayoutLGInput;
  grouping: GroupingCreateOneWithoutLayoutLGsInput;
}

export interface CardScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  cardType?: Maybe<CardType>;
  cardType_not?: Maybe<CardType>;
  cardType_in?: Maybe<CardType[] | CardType>;
  cardType_not_in?: Maybe<CardType[] | CardType>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
  OR?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
  NOT?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
}

export type LayoutLGWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput;
  data: CardUpdateManyDataInput;
}

export interface ItemCreateInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<ItemType>;
  alertID?: Maybe<Int>;
  logID?: Maybe<String>;
  triggerTime: String;
  name?: Maybe<String>;
  message?: Maybe<String>;
  level?: Maybe<Level>;
  source?: Maybe<Source>;
  trigger: EntityCreateOneWithoutItemsInput;
  hour: HourCreateOneWithoutItemsInput;
  day: DayCreateOneWithoutItemsInput;
}

export interface CardUpdateManyDataInput {
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
}

export type LayoutMDWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GroupingUpsertWithoutLayoutLGsInput {
  update: GroupingUpdateWithoutLayoutLGsDataInput;
  create: GroupingCreateWithoutLayoutLGsInput;
}

export interface HourCreateInput {
  id?: Maybe<ID_Input>;
  value: Int;
  hourDayMonthYear: String;
  day: DayCreateOneWithoutHoursInput;
  items?: Maybe<ItemCreateManyWithoutHourInput>;
}

export interface LayoutLGUpsertWithoutCardInput {
  update: LayoutLGUpdateWithoutCardDataInput;
  create: LayoutLGCreateWithoutCardInput;
}

export type LayoutSMWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CardUpdateManyMutationInput {
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
}

export interface GroupingCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard: DashboardCreateOneWithoutGroupingsInput;
  chips?: Maybe<GroupingCreatechipsInput>;
  cards?: Maybe<CardCreateManyWithoutGroupingInput>;
  layoutLGs?: Maybe<LayoutLGCreateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDCreateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMCreateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSCreateManyWithoutGroupingInput>;
}

export interface DayUpsertWithWhereUniqueWithoutMonthInput {
  where: DayWhereUniqueInput;
  update: DayUpdateWithoutMonthDataInput;
  create: DayCreateWithoutMonthInput;
}

export type LayoutXSWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuarterUpsertWithoutDaysInput {
  update: QuarterUpdateWithoutDaysDataInput;
  create: QuarterCreateWithoutDaysInput;
}

export interface EntityCreateInput {
  id?: Maybe<ID_Input>;
  entityID?: Maybe<String>;
  name?: Maybe<String>;
  linkForEntity?: Maybe<String>;
  type?: Maybe<EntityType>;
  source: Source;
  parent?: Maybe<EntityCreateOneWithoutParentInput>;
  items?: Maybe<ItemCreateManyWithoutTriggerInput>;
}

export interface DashboardCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  groupings?: Maybe<GroupingCreateManyWithoutDashboardInput>;
}

export type MonthWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  monthYear?: Maybe<String>;
}>;

export interface GroupingCreateManyWithoutDashboardInput {
  create?: Maybe<
    GroupingCreateWithoutDashboardInput[] | GroupingCreateWithoutDashboardInput
  >;
  connect?: Maybe<GroupingWhereUniqueInput[] | GroupingWhereUniqueInput>;
}

export interface QuarterUpdateManyDataInput {
  value?: Maybe<Int>;
  quarterYear?: Maybe<String>;
}

export interface GroupingCreateWithoutDashboardInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  chips?: Maybe<GroupingCreatechipsInput>;
  cards?: Maybe<CardCreateManyWithoutGroupingInput>;
  layoutLGs?: Maybe<LayoutLGCreateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDCreateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMCreateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSCreateManyWithoutGroupingInput>;
}

export type QuarterWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  quarterYear?: Maybe<String>;
}>;

export interface DashboardUpdateInput {
  name?: Maybe<String>;
  groupings?: Maybe<GroupingUpdateManyWithoutDashboardInput>;
}

export interface QuarterUpsertWithWhereUniqueWithoutYearInput {
  where: QuarterWhereUniqueInput;
  update: QuarterUpdateWithoutYearDataInput;
  create: QuarterCreateWithoutYearInput;
}

export interface GroupingUpdateManyWithoutDashboardInput {
  create?: Maybe<
    GroupingCreateWithoutDashboardInput[] | GroupingCreateWithoutDashboardInput
  >;
  delete?: Maybe<GroupingWhereUniqueInput[] | GroupingWhereUniqueInput>;
  connect?: Maybe<GroupingWhereUniqueInput[] | GroupingWhereUniqueInput>;
  set?: Maybe<GroupingWhereUniqueInput[] | GroupingWhereUniqueInput>;
  disconnect?: Maybe<GroupingWhereUniqueInput[] | GroupingWhereUniqueInput>;
  update?: Maybe<
    | GroupingUpdateWithWhereUniqueWithoutDashboardInput[]
    | GroupingUpdateWithWhereUniqueWithoutDashboardInput
  >;
  upsert?: Maybe<
    | GroupingUpsertWithWhereUniqueWithoutDashboardInput[]
    | GroupingUpsertWithWhereUniqueWithoutDashboardInput
  >;
  deleteMany?: Maybe<GroupingScalarWhereInput[] | GroupingScalarWhereInput>;
  updateMany?: Maybe<
    | GroupingUpdateManyWithWhereNestedInput[]
    | GroupingUpdateManyWithWhereNestedInput
  >;
}

export type WeekWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  weekYear?: Maybe<String>;
}>;

export interface GroupingUpdateWithWhereUniqueWithoutDashboardInput {
  where: GroupingWhereUniqueInput;
  data: GroupingUpdateWithoutDashboardDataInput;
}

export interface YearUpsertWithoutWeeksInput {
  update: YearUpdateWithoutWeeksDataInput;
  create: YearCreateWithoutWeeksInput;
}

export interface GroupingUpdateWithoutDashboardDataInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  chips?: Maybe<GroupingUpdatechipsInput>;
  cards?: Maybe<CardUpdateManyWithoutGroupingInput>;
  layoutLGs?: Maybe<LayoutLGUpdateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDUpdateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMUpdateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSUpdateManyWithoutGroupingInput>;
}

export type YearWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  value?: Maybe<Int>;
}>;

export interface GroupingUpsertWithWhereUniqueWithoutDashboardInput {
  where: GroupingWhereUniqueInput;
  update: GroupingUpdateWithoutDashboardDataInput;
  create: GroupingCreateWithoutDashboardInput;
}

export interface MonthUpdateManyWithWhereNestedInput {
  where: MonthScalarWhereInput;
  data: MonthUpdateManyDataInput;
}

export interface GroupingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  subtitle?: Maybe<String>;
  subtitle_not?: Maybe<String>;
  subtitle_in?: Maybe<String[] | String>;
  subtitle_not_in?: Maybe<String[] | String>;
  subtitle_lt?: Maybe<String>;
  subtitle_lte?: Maybe<String>;
  subtitle_gt?: Maybe<String>;
  subtitle_gte?: Maybe<String>;
  subtitle_contains?: Maybe<String>;
  subtitle_not_contains?: Maybe<String>;
  subtitle_starts_with?: Maybe<String>;
  subtitle_not_starts_with?: Maybe<String>;
  subtitle_ends_with?: Maybe<String>;
  subtitle_not_ends_with?: Maybe<String>;
  AND?: Maybe<GroupingScalarWhereInput[] | GroupingScalarWhereInput>;
  OR?: Maybe<GroupingScalarWhereInput[] | GroupingScalarWhereInput>;
  NOT?: Maybe<GroupingScalarWhereInput[] | GroupingScalarWhereInput>;
}

export interface MonthUpsertWithWhereUniqueWithoutYearInput {
  where: MonthWhereUniqueInput;
  update: MonthUpdateWithoutYearDataInput;
  create: MonthCreateWithoutYearInput;
}

export interface GroupingUpdateManyWithWhereNestedInput {
  where: GroupingScalarWhereInput;
  data: GroupingUpdateManyDataInput;
}

export interface CardCreateInput {
  id?: Maybe<ID_Input>;
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutLG: LayoutLGCreateOneWithoutCardInput;
  layoutMD: LayoutMDCreateOneWithoutCardInput;
  layoutSM: LayoutSMCreateOneWithoutCardInput;
  layoutXS: LayoutXSCreateOneWithoutCardInput;
  grouping: GroupingCreateOneWithoutCardsInput;
}

export interface GroupingUpdateManyDataInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  chips?: Maybe<GroupingUpdatechipsInput>;
}

export interface LayoutLGCreateWithoutCardInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  grouping: GroupingCreateOneWithoutLayoutLGsInput;
}

export interface DashboardUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface GroupingCreateWithoutLayoutLGsInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard: DashboardCreateOneWithoutGroupingsInput;
  chips?: Maybe<GroupingCreatechipsInput>;
  cards?: Maybe<CardCreateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDCreateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMCreateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSCreateManyWithoutGroupingInput>;
}

export interface DayCreateInput {
  id?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  dayMonthYear: String;
  year: YearCreateOneInput;
  quarter: QuarterCreateOneWithoutDaysInput;
  week: WeekCreateOneWithoutDaysInput;
  month: MonthCreateOneWithoutDaysInput;
  hours?: Maybe<HourCreateManyWithoutDayInput>;
  items?: Maybe<ItemCreateManyWithoutDayInput>;
}

export interface DashboardCreateWithoutGroupingsInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface YearCreateOneInput {
  create?: Maybe<YearCreateInput>;
  connect?: Maybe<YearWhereUniqueInput>;
}

export interface CardCreateManyWithoutGroupingInput {
  create?: Maybe<
    CardCreateWithoutGroupingInput[] | CardCreateWithoutGroupingInput
  >;
  connect?: Maybe<CardWhereUniqueInput[] | CardWhereUniqueInput>;
}

export interface YearCreateInput {
  id?: Maybe<ID_Input>;
  value: Int;
  quarters?: Maybe<QuarterCreateManyWithoutYearInput>;
  months?: Maybe<MonthCreateManyWithoutYearInput>;
  weeks?: Maybe<WeekCreateManyWithoutYearInput>;
}

export interface LayoutMDCreateOneWithoutCardInput {
  create?: Maybe<LayoutMDCreateWithoutCardInput>;
  connect?: Maybe<LayoutMDWhereUniqueInput>;
}

export interface QuarterCreateManyWithoutYearInput {
  create?: Maybe<
    QuarterCreateWithoutYearInput[] | QuarterCreateWithoutYearInput
  >;
  connect?: Maybe<QuarterWhereUniqueInput[] | QuarterWhereUniqueInput>;
}

export interface GroupingCreateOneWithoutLayoutMDsInput {
  create?: Maybe<GroupingCreateWithoutLayoutMDsInput>;
  connect?: Maybe<GroupingWhereUniqueInput>;
}

export interface QuarterCreateWithoutYearInput {
  id?: Maybe<ID_Input>;
  value: Int;
  quarterYear: String;
  days?: Maybe<DayCreateManyWithoutQuarterInput>;
}

export interface LayoutLGCreateManyWithoutGroupingInput {
  create?: Maybe<
    LayoutLGCreateWithoutGroupingInput[] | LayoutLGCreateWithoutGroupingInput
  >;
  connect?: Maybe<LayoutLGWhereUniqueInput[] | LayoutLGWhereUniqueInput>;
}

export interface DayCreateManyWithoutQuarterInput {
  create?: Maybe<DayCreateWithoutQuarterInput[] | DayCreateWithoutQuarterInput>;
  connect?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
}

export interface CardCreateOneWithoutLayoutLGInput {
  create?: Maybe<CardCreateWithoutLayoutLGInput>;
  connect?: Maybe<CardWhereUniqueInput>;
}

export interface DayCreateWithoutQuarterInput {
  id?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  dayMonthYear: String;
  year: YearCreateOneInput;
  week: WeekCreateOneWithoutDaysInput;
  month: MonthCreateOneWithoutDaysInput;
  hours?: Maybe<HourCreateManyWithoutDayInput>;
  items?: Maybe<ItemCreateManyWithoutDayInput>;
}

export interface LayoutSMCreateOneWithoutCardInput {
  create?: Maybe<LayoutSMCreateWithoutCardInput>;
  connect?: Maybe<LayoutSMWhereUniqueInput>;
}

export interface WeekCreateOneWithoutDaysInput {
  create?: Maybe<WeekCreateWithoutDaysInput>;
  connect?: Maybe<WeekWhereUniqueInput>;
}

export interface GroupingCreateOneWithoutLayoutSMsInput {
  create?: Maybe<GroupingCreateWithoutLayoutSMsInput>;
  connect?: Maybe<GroupingWhereUniqueInput>;
}

export interface WeekCreateWithoutDaysInput {
  id?: Maybe<ID_Input>;
  value: Int;
  weekYear: String;
  year: YearCreateOneWithoutWeeksInput;
}

export interface LayoutMDCreateManyWithoutGroupingInput {
  create?: Maybe<
    LayoutMDCreateWithoutGroupingInput[] | LayoutMDCreateWithoutGroupingInput
  >;
  connect?: Maybe<LayoutMDWhereUniqueInput[] | LayoutMDWhereUniqueInput>;
}

export interface YearCreateOneWithoutWeeksInput {
  create?: Maybe<YearCreateWithoutWeeksInput>;
  connect?: Maybe<YearWhereUniqueInput>;
}

export interface CardCreateOneWithoutLayoutMDInput {
  create?: Maybe<CardCreateWithoutLayoutMDInput>;
  connect?: Maybe<CardWhereUniqueInput>;
}

export interface YearCreateWithoutWeeksInput {
  id?: Maybe<ID_Input>;
  value: Int;
  quarters?: Maybe<QuarterCreateManyWithoutYearInput>;
  months?: Maybe<MonthCreateManyWithoutYearInput>;
}

export interface LayoutXSCreateOneWithoutCardInput {
  create?: Maybe<LayoutXSCreateWithoutCardInput>;
  connect?: Maybe<LayoutXSWhereUniqueInput>;
}

export interface MonthCreateManyWithoutYearInput {
  create?: Maybe<MonthCreateWithoutYearInput[] | MonthCreateWithoutYearInput>;
  connect?: Maybe<MonthWhereUniqueInput[] | MonthWhereUniqueInput>;
}

export interface GroupingCreateOneWithoutLayoutXSsInput {
  create?: Maybe<GroupingCreateWithoutLayoutXSsInput>;
  connect?: Maybe<GroupingWhereUniqueInput>;
}

export interface MonthCreateWithoutYearInput {
  id?: Maybe<ID_Input>;
  value: Int;
  monthYear: String;
  days?: Maybe<DayCreateManyWithoutMonthInput>;
}

export interface LayoutSMCreateManyWithoutGroupingInput {
  create?: Maybe<
    LayoutSMCreateWithoutGroupingInput[] | LayoutSMCreateWithoutGroupingInput
  >;
  connect?: Maybe<LayoutSMWhereUniqueInput[] | LayoutSMWhereUniqueInput>;
}

export interface DayCreateManyWithoutMonthInput {
  create?: Maybe<DayCreateWithoutMonthInput[] | DayCreateWithoutMonthInput>;
  connect?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
}

export interface CardCreateOneWithoutLayoutSMInput {
  create?: Maybe<CardCreateWithoutLayoutSMInput>;
  connect?: Maybe<CardWhereUniqueInput>;
}

export interface DayCreateWithoutMonthInput {
  id?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  dayMonthYear: String;
  year: YearCreateOneInput;
  quarter: QuarterCreateOneWithoutDaysInput;
  week: WeekCreateOneWithoutDaysInput;
  hours?: Maybe<HourCreateManyWithoutDayInput>;
  items?: Maybe<ItemCreateManyWithoutDayInput>;
}

export interface GroupingCreateOneWithoutCardsInput {
  create?: Maybe<GroupingCreateWithoutCardsInput>;
  connect?: Maybe<GroupingWhereUniqueInput>;
}

export interface QuarterCreateOneWithoutDaysInput {
  create?: Maybe<QuarterCreateWithoutDaysInput>;
  connect?: Maybe<QuarterWhereUniqueInput>;
}

export interface LayoutXSCreateManyWithoutGroupingInput {
  create?: Maybe<
    LayoutXSCreateWithoutGroupingInput[] | LayoutXSCreateWithoutGroupingInput
  >;
  connect?: Maybe<LayoutXSWhereUniqueInput[] | LayoutXSWhereUniqueInput>;
}

export interface QuarterCreateWithoutDaysInput {
  id?: Maybe<ID_Input>;
  value: Int;
  quarterYear: String;
  year: YearCreateOneWithoutQuartersInput;
}

export interface CardCreateOneWithoutLayoutXSInput {
  create?: Maybe<CardCreateWithoutLayoutXSInput>;
  connect?: Maybe<CardWhereUniqueInput>;
}

export interface YearCreateOneWithoutQuartersInput {
  create?: Maybe<YearCreateWithoutQuartersInput>;
  connect?: Maybe<YearWhereUniqueInput>;
}

export interface CardUpdateInput {
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutLG?: Maybe<LayoutLGUpdateOneRequiredWithoutCardInput>;
  layoutMD?: Maybe<LayoutMDUpdateOneRequiredWithoutCardInput>;
  layoutSM?: Maybe<LayoutSMUpdateOneRequiredWithoutCardInput>;
  layoutXS?: Maybe<LayoutXSUpdateOneRequiredWithoutCardInput>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutCardsInput>;
}

export interface YearCreateWithoutQuartersInput {
  id?: Maybe<ID_Input>;
  value: Int;
  months?: Maybe<MonthCreateManyWithoutYearInput>;
  weeks?: Maybe<WeekCreateManyWithoutYearInput>;
}

export interface LayoutLGUpdateWithoutCardDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutLayoutLGsInput>;
}

export interface WeekCreateManyWithoutYearInput {
  create?: Maybe<WeekCreateWithoutYearInput[] | WeekCreateWithoutYearInput>;
  connect?: Maybe<WeekWhereUniqueInput[] | WeekWhereUniqueInput>;
}

export interface GroupingUpdateWithoutLayoutLGsDataInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard?: Maybe<DashboardUpdateOneRequiredWithoutGroupingsInput>;
  chips?: Maybe<GroupingUpdatechipsInput>;
  cards?: Maybe<CardUpdateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDUpdateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMUpdateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSUpdateManyWithoutGroupingInput>;
}

export interface WeekCreateWithoutYearInput {
  id?: Maybe<ID_Input>;
  value: Int;
  weekYear: String;
  days?: Maybe<DayCreateManyWithoutWeekInput>;
}

export interface DashboardUpdateWithoutGroupingsDataInput {
  name?: Maybe<String>;
}

export interface DayCreateManyWithoutWeekInput {
  create?: Maybe<DayCreateWithoutWeekInput[] | DayCreateWithoutWeekInput>;
  connect?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
}

export interface GroupingUpdatechipsInput {
  set?: Maybe<String[] | String>;
}

export interface DayCreateWithoutWeekInput {
  id?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  dayMonthYear: String;
  year: YearCreateOneInput;
  quarter: QuarterCreateOneWithoutDaysInput;
  month: MonthCreateOneWithoutDaysInput;
  hours?: Maybe<HourCreateManyWithoutDayInput>;
  items?: Maybe<ItemCreateManyWithoutDayInput>;
}

export interface CardUpdateWithWhereUniqueWithoutGroupingInput {
  where: CardWhereUniqueInput;
  data: CardUpdateWithoutGroupingDataInput;
}

export interface MonthCreateOneWithoutDaysInput {
  create?: Maybe<MonthCreateWithoutDaysInput>;
  connect?: Maybe<MonthWhereUniqueInput>;
}

export interface LayoutMDUpdateOneRequiredWithoutCardInput {
  create?: Maybe<LayoutMDCreateWithoutCardInput>;
  update?: Maybe<LayoutMDUpdateWithoutCardDataInput>;
  upsert?: Maybe<LayoutMDUpsertWithoutCardInput>;
  connect?: Maybe<LayoutMDWhereUniqueInput>;
}

export interface MonthCreateWithoutDaysInput {
  id?: Maybe<ID_Input>;
  value: Int;
  monthYear: String;
  year: YearCreateOneWithoutMonthsInput;
}

export interface GroupingUpdateOneRequiredWithoutLayoutMDsInput {
  create?: Maybe<GroupingCreateWithoutLayoutMDsInput>;
  update?: Maybe<GroupingUpdateWithoutLayoutMDsDataInput>;
  upsert?: Maybe<GroupingUpsertWithoutLayoutMDsInput>;
  connect?: Maybe<GroupingWhereUniqueInput>;
}

export interface YearCreateOneWithoutMonthsInput {
  create?: Maybe<YearCreateWithoutMonthsInput>;
  connect?: Maybe<YearWhereUniqueInput>;
}

export interface LayoutLGUpdateManyWithoutGroupingInput {
  create?: Maybe<
    LayoutLGCreateWithoutGroupingInput[] | LayoutLGCreateWithoutGroupingInput
  >;
  delete?: Maybe<LayoutLGWhereUniqueInput[] | LayoutLGWhereUniqueInput>;
  connect?: Maybe<LayoutLGWhereUniqueInput[] | LayoutLGWhereUniqueInput>;
  set?: Maybe<LayoutLGWhereUniqueInput[] | LayoutLGWhereUniqueInput>;
  disconnect?: Maybe<LayoutLGWhereUniqueInput[] | LayoutLGWhereUniqueInput>;
  update?: Maybe<
    | LayoutLGUpdateWithWhereUniqueWithoutGroupingInput[]
    | LayoutLGUpdateWithWhereUniqueWithoutGroupingInput
  >;
  upsert?: Maybe<
    | LayoutLGUpsertWithWhereUniqueWithoutGroupingInput[]
    | LayoutLGUpsertWithWhereUniqueWithoutGroupingInput
  >;
  deleteMany?: Maybe<LayoutLGScalarWhereInput[] | LayoutLGScalarWhereInput>;
  updateMany?: Maybe<
    | LayoutLGUpdateManyWithWhereNestedInput[]
    | LayoutLGUpdateManyWithWhereNestedInput
  >;
}

export interface YearCreateWithoutMonthsInput {
  id?: Maybe<ID_Input>;
  value: Int;
  quarters?: Maybe<QuarterCreateManyWithoutYearInput>;
  weeks?: Maybe<WeekCreateManyWithoutYearInput>;
}

export interface LayoutLGUpdateWithoutGroupingDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  card?: Maybe<CardUpdateOneRequiredWithoutLayoutLGInput>;
}

export interface HourCreateManyWithoutDayInput {
  create?: Maybe<HourCreateWithoutDayInput[] | HourCreateWithoutDayInput>;
  connect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
}

export interface CardUpdateWithoutLayoutLGDataInput {
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutMD?: Maybe<LayoutMDUpdateOneRequiredWithoutCardInput>;
  layoutSM?: Maybe<LayoutSMUpdateOneRequiredWithoutCardInput>;
  layoutXS?: Maybe<LayoutXSUpdateOneRequiredWithoutCardInput>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutCardsInput>;
}

export interface HourCreateWithoutDayInput {
  id?: Maybe<ID_Input>;
  value: Int;
  hourDayMonthYear: String;
  items?: Maybe<ItemCreateManyWithoutHourInput>;
}

export interface LayoutSMUpdateWithoutCardDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutLayoutSMsInput>;
}

export interface ItemCreateManyWithoutHourInput {
  create?: Maybe<ItemCreateWithoutHourInput[] | ItemCreateWithoutHourInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface GroupingUpdateWithoutLayoutSMsDataInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard?: Maybe<DashboardUpdateOneRequiredWithoutGroupingsInput>;
  chips?: Maybe<GroupingUpdatechipsInput>;
  cards?: Maybe<CardUpdateManyWithoutGroupingInput>;
  layoutLGs?: Maybe<LayoutLGUpdateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDUpdateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSUpdateManyWithoutGroupingInput>;
}

export interface ItemCreateWithoutHourInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<ItemType>;
  alertID?: Maybe<Int>;
  logID?: Maybe<String>;
  triggerTime: String;
  name?: Maybe<String>;
  message?: Maybe<String>;
  level?: Maybe<Level>;
  source?: Maybe<Source>;
  trigger: EntityCreateOneWithoutItemsInput;
  day: DayCreateOneWithoutItemsInput;
}

export interface LayoutMDUpdateWithWhereUniqueWithoutGroupingInput {
  where: LayoutMDWhereUniqueInput;
  data: LayoutMDUpdateWithoutGroupingDataInput;
}

export interface EntityCreateOneWithoutItemsInput {
  create?: Maybe<EntityCreateWithoutItemsInput>;
  connect?: Maybe<EntityWhereUniqueInput>;
}

export interface CardUpdateOneRequiredWithoutLayoutMDInput {
  create?: Maybe<CardCreateWithoutLayoutMDInput>;
  update?: Maybe<CardUpdateWithoutLayoutMDDataInput>;
  upsert?: Maybe<CardUpsertWithoutLayoutMDInput>;
  connect?: Maybe<CardWhereUniqueInput>;
}

export interface EntityCreateWithoutItemsInput {
  id?: Maybe<ID_Input>;
  entityID?: Maybe<String>;
  name?: Maybe<String>;
  linkForEntity?: Maybe<String>;
  type?: Maybe<EntityType>;
  source: Source;
  parent?: Maybe<EntityCreateOneWithoutParentInput>;
}

export interface LayoutXSUpdateOneRequiredWithoutCardInput {
  create?: Maybe<LayoutXSCreateWithoutCardInput>;
  update?: Maybe<LayoutXSUpdateWithoutCardDataInput>;
  upsert?: Maybe<LayoutXSUpsertWithoutCardInput>;
  connect?: Maybe<LayoutXSWhereUniqueInput>;
}

export interface EntityCreateOneWithoutParentInput {
  create?: Maybe<EntityCreateWithoutParentInput>;
  connect?: Maybe<EntityWhereUniqueInput>;
}

export interface YearSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<YearWhereInput>;
  AND?: Maybe<YearSubscriptionWhereInput[] | YearSubscriptionWhereInput>;
  OR?: Maybe<YearSubscriptionWhereInput[] | YearSubscriptionWhereInput>;
  NOT?: Maybe<YearSubscriptionWhereInput[] | YearSubscriptionWhereInput>;
}

export interface EntityCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  entityID?: Maybe<String>;
  name?: Maybe<String>;
  linkForEntity?: Maybe<String>;
  type?: Maybe<EntityType>;
  source: Source;
  items?: Maybe<ItemCreateManyWithoutTriggerInput>;
}

export interface LayoutSMUpdateManyWithoutGroupingInput {
  create?: Maybe<
    LayoutSMCreateWithoutGroupingInput[] | LayoutSMCreateWithoutGroupingInput
  >;
  delete?: Maybe<LayoutSMWhereUniqueInput[] | LayoutSMWhereUniqueInput>;
  connect?: Maybe<LayoutSMWhereUniqueInput[] | LayoutSMWhereUniqueInput>;
  set?: Maybe<LayoutSMWhereUniqueInput[] | LayoutSMWhereUniqueInput>;
  disconnect?: Maybe<LayoutSMWhereUniqueInput[] | LayoutSMWhereUniqueInput>;
  update?: Maybe<
    | LayoutSMUpdateWithWhereUniqueWithoutGroupingInput[]
    | LayoutSMUpdateWithWhereUniqueWithoutGroupingInput
  >;
  upsert?: Maybe<
    | LayoutSMUpsertWithWhereUniqueWithoutGroupingInput[]
    | LayoutSMUpsertWithWhereUniqueWithoutGroupingInput
  >;
  deleteMany?: Maybe<LayoutSMScalarWhereInput[] | LayoutSMScalarWhereInput>;
  updateMany?: Maybe<
    | LayoutSMUpdateManyWithWhereNestedInput[]
    | LayoutSMUpdateManyWithWhereNestedInput
  >;
}

export interface ItemCreateManyWithoutTriggerInput {
  create?: Maybe<
    ItemCreateWithoutTriggerInput[] | ItemCreateWithoutTriggerInput
  >;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface LayoutSMUpdateWithoutGroupingDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  card?: Maybe<CardUpdateOneRequiredWithoutLayoutSMInput>;
}

export interface ItemCreateWithoutTriggerInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<ItemType>;
  alertID?: Maybe<Int>;
  logID?: Maybe<String>;
  triggerTime: String;
  name?: Maybe<String>;
  message?: Maybe<String>;
  level?: Maybe<Level>;
  source?: Maybe<Source>;
  hour: HourCreateOneWithoutItemsInput;
  day: DayCreateOneWithoutItemsInput;
}

export interface CardUpdateWithoutLayoutSMDataInput {
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutLG?: Maybe<LayoutLGUpdateOneRequiredWithoutCardInput>;
  layoutMD?: Maybe<LayoutMDUpdateOneRequiredWithoutCardInput>;
  layoutXS?: Maybe<LayoutXSUpdateOneRequiredWithoutCardInput>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutCardsInput>;
}

export interface HourCreateOneWithoutItemsInput {
  create?: Maybe<HourCreateWithoutItemsInput>;
  connect?: Maybe<HourWhereUniqueInput>;
}

export interface GroupingUpdateWithoutCardsDataInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard?: Maybe<DashboardUpdateOneRequiredWithoutGroupingsInput>;
  chips?: Maybe<GroupingUpdatechipsInput>;
  layoutLGs?: Maybe<LayoutLGUpdateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDUpdateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMUpdateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSUpdateManyWithoutGroupingInput>;
}

export interface HourCreateWithoutItemsInput {
  id?: Maybe<ID_Input>;
  value: Int;
  hourDayMonthYear: String;
  day: DayCreateOneWithoutHoursInput;
}

export interface LayoutXSUpdateWithWhereUniqueWithoutGroupingInput {
  where: LayoutXSWhereUniqueInput;
  data: LayoutXSUpdateWithoutGroupingDataInput;
}

export interface DayCreateOneWithoutHoursInput {
  create?: Maybe<DayCreateWithoutHoursInput>;
  connect?: Maybe<DayWhereUniqueInput>;
}

export interface HourSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HourWhereInput>;
  AND?: Maybe<HourSubscriptionWhereInput[] | HourSubscriptionWhereInput>;
  OR?: Maybe<HourSubscriptionWhereInput[] | HourSubscriptionWhereInput>;
  NOT?: Maybe<HourSubscriptionWhereInput[] | HourSubscriptionWhereInput>;
}

export interface DayCreateWithoutHoursInput {
  id?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  dayMonthYear: String;
  year: YearCreateOneInput;
  quarter: QuarterCreateOneWithoutDaysInput;
  week: WeekCreateOneWithoutDaysInput;
  month: MonthCreateOneWithoutDaysInput;
  items?: Maybe<ItemCreateManyWithoutDayInput>;
}

export interface DashboardSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DashboardWhereInput>;
  AND?: Maybe<
    DashboardSubscriptionWhereInput[] | DashboardSubscriptionWhereInput
  >;
  OR?: Maybe<
    DashboardSubscriptionWhereInput[] | DashboardSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DashboardSubscriptionWhereInput[] | DashboardSubscriptionWhereInput
  >;
}

export interface ItemCreateManyWithoutDayInput {
  create?: Maybe<ItemCreateWithoutDayInput[] | ItemCreateWithoutDayInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface CardSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CardWhereInput>;
  AND?: Maybe<CardSubscriptionWhereInput[] | CardSubscriptionWhereInput>;
  OR?: Maybe<CardSubscriptionWhereInput[] | CardSubscriptionWhereInput>;
  NOT?: Maybe<CardSubscriptionWhereInput[] | CardSubscriptionWhereInput>;
}

export interface ItemCreateWithoutDayInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<ItemType>;
  alertID?: Maybe<Int>;
  logID?: Maybe<String>;
  triggerTime: String;
  name?: Maybe<String>;
  message?: Maybe<String>;
  level?: Maybe<Level>;
  source?: Maybe<Source>;
  trigger: EntityCreateOneWithoutItemsInput;
  hour: HourCreateOneWithoutItemsInput;
}

export interface WeekUpdateManyMutationInput {
  value?: Maybe<Int>;
  weekYear?: Maybe<String>;
}

export interface DayCreateOneWithoutItemsInput {
  create?: Maybe<DayCreateWithoutItemsInput>;
  connect?: Maybe<DayWhereUniqueInput>;
}

export interface DayWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  dayMonthYear?: Maybe<String>;
  dayMonthYear_not?: Maybe<String>;
  dayMonthYear_in?: Maybe<String[] | String>;
  dayMonthYear_not_in?: Maybe<String[] | String>;
  dayMonthYear_lt?: Maybe<String>;
  dayMonthYear_lte?: Maybe<String>;
  dayMonthYear_gt?: Maybe<String>;
  dayMonthYear_gte?: Maybe<String>;
  dayMonthYear_contains?: Maybe<String>;
  dayMonthYear_not_contains?: Maybe<String>;
  dayMonthYear_starts_with?: Maybe<String>;
  dayMonthYear_not_starts_with?: Maybe<String>;
  dayMonthYear_ends_with?: Maybe<String>;
  dayMonthYear_not_ends_with?: Maybe<String>;
  year?: Maybe<YearWhereInput>;
  quarter?: Maybe<QuarterWhereInput>;
  week?: Maybe<WeekWhereInput>;
  month?: Maybe<MonthWhereInput>;
  hours_every?: Maybe<HourWhereInput>;
  hours_some?: Maybe<HourWhereInput>;
  hours_none?: Maybe<HourWhereInput>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  AND?: Maybe<DayWhereInput[] | DayWhereInput>;
  OR?: Maybe<DayWhereInput[] | DayWhereInput>;
  NOT?: Maybe<DayWhereInput[] | DayWhereInput>;
}

export interface DayCreateWithoutItemsInput {
  id?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  dayMonthYear: String;
  year: YearCreateOneInput;
  quarter: QuarterCreateOneWithoutDaysInput;
  week: WeekCreateOneWithoutDaysInput;
  month: MonthCreateOneWithoutDaysInput;
  hours?: Maybe<HourCreateManyWithoutDayInput>;
}

export interface LayoutXSWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  w?: Maybe<Int>;
  w_not?: Maybe<Int>;
  w_in?: Maybe<Int[] | Int>;
  w_not_in?: Maybe<Int[] | Int>;
  w_lt?: Maybe<Int>;
  w_lte?: Maybe<Int>;
  w_gt?: Maybe<Int>;
  w_gte?: Maybe<Int>;
  h?: Maybe<Int>;
  h_not?: Maybe<Int>;
  h_in?: Maybe<Int[] | Int>;
  h_not_in?: Maybe<Int[] | Int>;
  h_lt?: Maybe<Int>;
  h_lte?: Maybe<Int>;
  h_gt?: Maybe<Int>;
  h_gte?: Maybe<Int>;
  card?: Maybe<CardWhereInput>;
  grouping?: Maybe<GroupingWhereInput>;
  AND?: Maybe<LayoutXSWhereInput[] | LayoutXSWhereInput>;
  OR?: Maybe<LayoutXSWhereInput[] | LayoutXSWhereInput>;
  NOT?: Maybe<LayoutXSWhereInput[] | LayoutXSWhereInput>;
}

export interface DayUpdateInput {
  value?: Maybe<Int>;
  dayMonthYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredInput>;
  quarter?: Maybe<QuarterUpdateOneRequiredWithoutDaysInput>;
  week?: Maybe<WeekUpdateOneRequiredWithoutDaysInput>;
  month?: Maybe<MonthUpdateOneRequiredWithoutDaysInput>;
  hours?: Maybe<HourUpdateManyWithoutDayInput>;
  items?: Maybe<ItemUpdateManyWithoutDayInput>;
}

export interface LayoutLGWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  w?: Maybe<Int>;
  w_not?: Maybe<Int>;
  w_in?: Maybe<Int[] | Int>;
  w_not_in?: Maybe<Int[] | Int>;
  w_lt?: Maybe<Int>;
  w_lte?: Maybe<Int>;
  w_gt?: Maybe<Int>;
  w_gte?: Maybe<Int>;
  h?: Maybe<Int>;
  h_not?: Maybe<Int>;
  h_in?: Maybe<Int[] | Int>;
  h_not_in?: Maybe<Int[] | Int>;
  h_lt?: Maybe<Int>;
  h_lte?: Maybe<Int>;
  h_gt?: Maybe<Int>;
  h_gte?: Maybe<Int>;
  card?: Maybe<CardWhereInput>;
  grouping?: Maybe<GroupingWhereInput>;
  AND?: Maybe<LayoutLGWhereInput[] | LayoutLGWhereInput>;
  OR?: Maybe<LayoutLGWhereInput[] | LayoutLGWhereInput>;
  NOT?: Maybe<LayoutLGWhereInput[] | LayoutLGWhereInput>;
}

export interface YearUpdateOneRequiredInput {
  create?: Maybe<YearCreateInput>;
  update?: Maybe<YearUpdateDataInput>;
  upsert?: Maybe<YearUpsertNestedInput>;
  connect?: Maybe<YearWhereUniqueInput>;
}

export interface GroupingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  subtitle?: Maybe<String>;
  subtitle_not?: Maybe<String>;
  subtitle_in?: Maybe<String[] | String>;
  subtitle_not_in?: Maybe<String[] | String>;
  subtitle_lt?: Maybe<String>;
  subtitle_lte?: Maybe<String>;
  subtitle_gt?: Maybe<String>;
  subtitle_gte?: Maybe<String>;
  subtitle_contains?: Maybe<String>;
  subtitle_not_contains?: Maybe<String>;
  subtitle_starts_with?: Maybe<String>;
  subtitle_not_starts_with?: Maybe<String>;
  subtitle_ends_with?: Maybe<String>;
  subtitle_not_ends_with?: Maybe<String>;
  dashboard?: Maybe<DashboardWhereInput>;
  cards_every?: Maybe<CardWhereInput>;
  cards_some?: Maybe<CardWhereInput>;
  cards_none?: Maybe<CardWhereInput>;
  layoutLGs_every?: Maybe<LayoutLGWhereInput>;
  layoutLGs_some?: Maybe<LayoutLGWhereInput>;
  layoutLGs_none?: Maybe<LayoutLGWhereInput>;
  layoutMDs_every?: Maybe<LayoutMDWhereInput>;
  layoutMDs_some?: Maybe<LayoutMDWhereInput>;
  layoutMDs_none?: Maybe<LayoutMDWhereInput>;
  layoutSMs_every?: Maybe<LayoutSMWhereInput>;
  layoutSMs_some?: Maybe<LayoutSMWhereInput>;
  layoutSMs_none?: Maybe<LayoutSMWhereInput>;
  layoutXSs_every?: Maybe<LayoutXSWhereInput>;
  layoutXSs_some?: Maybe<LayoutXSWhereInput>;
  layoutXSs_none?: Maybe<LayoutXSWhereInput>;
  AND?: Maybe<GroupingWhereInput[] | GroupingWhereInput>;
  OR?: Maybe<GroupingWhereInput[] | GroupingWhereInput>;
  NOT?: Maybe<GroupingWhereInput[] | GroupingWhereInput>;
}

export interface YearUpdateDataInput {
  value?: Maybe<Int>;
  quarters?: Maybe<QuarterUpdateManyWithoutYearInput>;
  months?: Maybe<MonthUpdateManyWithoutYearInput>;
  weeks?: Maybe<WeekUpdateManyWithoutYearInput>;
}

export interface LayoutXSSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LayoutXSWhereInput>;
  AND?: Maybe<
    LayoutXSSubscriptionWhereInput[] | LayoutXSSubscriptionWhereInput
  >;
  OR?: Maybe<LayoutXSSubscriptionWhereInput[] | LayoutXSSubscriptionWhereInput>;
  NOT?: Maybe<
    LayoutXSSubscriptionWhereInput[] | LayoutXSSubscriptionWhereInput
  >;
}

export interface QuarterUpdateManyWithoutYearInput {
  create?: Maybe<
    QuarterCreateWithoutYearInput[] | QuarterCreateWithoutYearInput
  >;
  delete?: Maybe<QuarterWhereUniqueInput[] | QuarterWhereUniqueInput>;
  connect?: Maybe<QuarterWhereUniqueInput[] | QuarterWhereUniqueInput>;
  set?: Maybe<QuarterWhereUniqueInput[] | QuarterWhereUniqueInput>;
  disconnect?: Maybe<QuarterWhereUniqueInput[] | QuarterWhereUniqueInput>;
  update?: Maybe<
    | QuarterUpdateWithWhereUniqueWithoutYearInput[]
    | QuarterUpdateWithWhereUniqueWithoutYearInput
  >;
  upsert?: Maybe<
    | QuarterUpsertWithWhereUniqueWithoutYearInput[]
    | QuarterUpsertWithWhereUniqueWithoutYearInput
  >;
  deleteMany?: Maybe<QuarterScalarWhereInput[] | QuarterScalarWhereInput>;
  updateMany?: Maybe<
    | QuarterUpdateManyWithWhereNestedInput[]
    | QuarterUpdateManyWithWhereNestedInput
  >;
}

export interface MonthUpdateManyMutationInput {
  value?: Maybe<Int>;
  monthYear?: Maybe<String>;
}

export interface QuarterUpdateWithWhereUniqueWithoutYearInput {
  where: QuarterWhereUniqueInput;
  data: QuarterUpdateWithoutYearDataInput;
}

export type EntityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  entityID?: Maybe<String>;
  name?: Maybe<String>;
}>;

export interface QuarterUpdateWithoutYearDataInput {
  value?: Maybe<Int>;
  quarterYear?: Maybe<String>;
  days?: Maybe<DayUpdateManyWithoutQuarterInput>;
}

export interface LayoutSMUpdateManyMutationInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
}

export interface DayUpdateManyWithoutQuarterInput {
  create?: Maybe<DayCreateWithoutQuarterInput[] | DayCreateWithoutQuarterInput>;
  delete?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  connect?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  set?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  disconnect?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  update?: Maybe<
    | DayUpdateWithWhereUniqueWithoutQuarterInput[]
    | DayUpdateWithWhereUniqueWithoutQuarterInput
  >;
  upsert?: Maybe<
    | DayUpsertWithWhereUniqueWithoutQuarterInput[]
    | DayUpsertWithWhereUniqueWithoutQuarterInput
  >;
  deleteMany?: Maybe<DayScalarWhereInput[] | DayScalarWhereInput>;
  updateMany?: Maybe<
    DayUpdateManyWithWhereNestedInput[] | DayUpdateManyWithWhereNestedInput
  >;
}

export interface LayoutMDUpdateManyMutationInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
}

export interface DayUpdateWithWhereUniqueWithoutQuarterInput {
  where: DayWhereUniqueInput;
  data: DayUpdateWithoutQuarterDataInput;
}

export interface LayoutLGUpdateManyMutationInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
}

export interface DayUpdateWithoutQuarterDataInput {
  value?: Maybe<Int>;
  dayMonthYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredInput>;
  week?: Maybe<WeekUpdateOneRequiredWithoutDaysInput>;
  month?: Maybe<MonthUpdateOneRequiredWithoutDaysInput>;
  hours?: Maybe<HourUpdateManyWithoutDayInput>;
  items?: Maybe<ItemUpdateManyWithoutDayInput>;
}

export interface ItemUpdateManyMutationInput {
  type?: Maybe<ItemType>;
  alertID?: Maybe<Int>;
  logID?: Maybe<String>;
  triggerTime?: Maybe<String>;
  name?: Maybe<String>;
  message?: Maybe<String>;
  level?: Maybe<Level>;
  source?: Maybe<Source>;
}

export interface WeekUpdateOneRequiredWithoutDaysInput {
  create?: Maybe<WeekCreateWithoutDaysInput>;
  update?: Maybe<WeekUpdateWithoutDaysDataInput>;
  upsert?: Maybe<WeekUpsertWithoutDaysInput>;
  connect?: Maybe<WeekWhereUniqueInput>;
}

export interface HourUpdateManyMutationInput {
  value?: Maybe<Int>;
  hourDayMonthYear?: Maybe<String>;
}

export interface WeekUpdateWithoutDaysDataInput {
  value?: Maybe<Int>;
  weekYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredWithoutWeeksInput>;
}

export interface GroupingUpdateManyMutationInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  chips?: Maybe<GroupingUpdatechipsInput>;
}

export interface YearUpdateOneRequiredWithoutWeeksInput {
  create?: Maybe<YearCreateWithoutWeeksInput>;
  update?: Maybe<YearUpdateWithoutWeeksDataInput>;
  upsert?: Maybe<YearUpsertWithoutWeeksInput>;
  connect?: Maybe<YearWhereUniqueInput>;
}

export interface EntityUpdateManyMutationInput {
  entityID?: Maybe<String>;
  name?: Maybe<String>;
  linkForEntity?: Maybe<String>;
  type?: Maybe<EntityType>;
  source?: Maybe<Source>;
}

export interface YearUpdateWithoutWeeksDataInput {
  value?: Maybe<Int>;
  quarters?: Maybe<QuarterUpdateManyWithoutYearInput>;
  months?: Maybe<MonthUpdateManyWithoutYearInput>;
}

export interface DayUpdateManyMutationInput {
  value?: Maybe<Int>;
  dayMonthYear?: Maybe<String>;
}

export interface MonthUpdateManyWithoutYearInput {
  create?: Maybe<MonthCreateWithoutYearInput[] | MonthCreateWithoutYearInput>;
  delete?: Maybe<MonthWhereUniqueInput[] | MonthWhereUniqueInput>;
  connect?: Maybe<MonthWhereUniqueInput[] | MonthWhereUniqueInput>;
  set?: Maybe<MonthWhereUniqueInput[] | MonthWhereUniqueInput>;
  disconnect?: Maybe<MonthWhereUniqueInput[] | MonthWhereUniqueInput>;
  update?: Maybe<
    | MonthUpdateWithWhereUniqueWithoutYearInput[]
    | MonthUpdateWithWhereUniqueWithoutYearInput
  >;
  upsert?: Maybe<
    | MonthUpsertWithWhereUniqueWithoutYearInput[]
    | MonthUpsertWithWhereUniqueWithoutYearInput
  >;
  deleteMany?: Maybe<MonthScalarWhereInput[] | MonthScalarWhereInput>;
  updateMany?: Maybe<
    MonthUpdateManyWithWhereNestedInput[] | MonthUpdateManyWithWhereNestedInput
  >;
}

export interface QuarterUpdateManyWithWhereNestedInput {
  where: QuarterScalarWhereInput;
  data: QuarterUpdateManyDataInput;
}

export interface MonthUpdateWithWhereUniqueWithoutYearInput {
  where: MonthWhereUniqueInput;
  data: MonthUpdateWithoutYearDataInput;
}

export interface DayUpsertWithWhereUniqueWithoutQuarterInput {
  where: DayWhereUniqueInput;
  update: DayUpdateWithoutQuarterDataInput;
  create: DayCreateWithoutQuarterInput;
}

export interface MonthUpdateWithoutYearDataInput {
  value?: Maybe<Int>;
  monthYear?: Maybe<String>;
  days?: Maybe<DayUpdateManyWithoutMonthInput>;
}

export interface MonthUpdateManyDataInput {
  value?: Maybe<Int>;
  monthYear?: Maybe<String>;
}

export interface DayUpdateManyWithoutMonthInput {
  create?: Maybe<DayCreateWithoutMonthInput[] | DayCreateWithoutMonthInput>;
  delete?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  connect?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  set?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  disconnect?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  update?: Maybe<
    | DayUpdateWithWhereUniqueWithoutMonthInput[]
    | DayUpdateWithWhereUniqueWithoutMonthInput
  >;
  upsert?: Maybe<
    | DayUpsertWithWhereUniqueWithoutMonthInput[]
    | DayUpsertWithWhereUniqueWithoutMonthInput
  >;
  deleteMany?: Maybe<DayScalarWhereInput[] | DayScalarWhereInput>;
  updateMany?: Maybe<
    DayUpdateManyWithWhereNestedInput[] | DayUpdateManyWithWhereNestedInput
  >;
}

export interface MonthScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  monthYear?: Maybe<String>;
  monthYear_not?: Maybe<String>;
  monthYear_in?: Maybe<String[] | String>;
  monthYear_not_in?: Maybe<String[] | String>;
  monthYear_lt?: Maybe<String>;
  monthYear_lte?: Maybe<String>;
  monthYear_gt?: Maybe<String>;
  monthYear_gte?: Maybe<String>;
  monthYear_contains?: Maybe<String>;
  monthYear_not_contains?: Maybe<String>;
  monthYear_starts_with?: Maybe<String>;
  monthYear_not_starts_with?: Maybe<String>;
  monthYear_ends_with?: Maybe<String>;
  monthYear_not_ends_with?: Maybe<String>;
  AND?: Maybe<MonthScalarWhereInput[] | MonthScalarWhereInput>;
  OR?: Maybe<MonthScalarWhereInput[] | MonthScalarWhereInput>;
  NOT?: Maybe<MonthScalarWhereInput[] | MonthScalarWhereInput>;
}

export interface DayUpdateWithWhereUniqueWithoutMonthInput {
  where: DayWhereUniqueInput;
  data: DayUpdateWithoutMonthDataInput;
}

export interface LayoutLGCreateOneWithoutCardInput {
  create?: Maybe<LayoutLGCreateWithoutCardInput>;
  connect?: Maybe<LayoutLGWhereUniqueInput>;
}

export interface DayUpdateWithoutMonthDataInput {
  value?: Maybe<Int>;
  dayMonthYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredInput>;
  quarter?: Maybe<QuarterUpdateOneRequiredWithoutDaysInput>;
  week?: Maybe<WeekUpdateOneRequiredWithoutDaysInput>;
  hours?: Maybe<HourUpdateManyWithoutDayInput>;
  items?: Maybe<ItemUpdateManyWithoutDayInput>;
}

export interface DashboardCreateOneWithoutGroupingsInput {
  create?: Maybe<DashboardCreateWithoutGroupingsInput>;
  connect?: Maybe<DashboardWhereUniqueInput>;
}

export interface QuarterUpdateOneRequiredWithoutDaysInput {
  create?: Maybe<QuarterCreateWithoutDaysInput>;
  update?: Maybe<QuarterUpdateWithoutDaysDataInput>;
  upsert?: Maybe<QuarterUpsertWithoutDaysInput>;
  connect?: Maybe<QuarterWhereUniqueInput>;
}

export interface CardCreateWithoutGroupingInput {
  id?: Maybe<ID_Input>;
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutLG: LayoutLGCreateOneWithoutCardInput;
  layoutMD: LayoutMDCreateOneWithoutCardInput;
  layoutSM: LayoutSMCreateOneWithoutCardInput;
  layoutXS: LayoutXSCreateOneWithoutCardInput;
}

export interface QuarterUpdateWithoutDaysDataInput {
  value?: Maybe<Int>;
  quarterYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredWithoutQuartersInput>;
}

export interface GroupingCreateWithoutLayoutMDsInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard: DashboardCreateOneWithoutGroupingsInput;
  chips?: Maybe<GroupingCreatechipsInput>;
  cards?: Maybe<CardCreateManyWithoutGroupingInput>;
  layoutLGs?: Maybe<LayoutLGCreateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMCreateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSCreateManyWithoutGroupingInput>;
}

export interface YearUpdateOneRequiredWithoutQuartersInput {
  create?: Maybe<YearCreateWithoutQuartersInput>;
  update?: Maybe<YearUpdateWithoutQuartersDataInput>;
  upsert?: Maybe<YearUpsertWithoutQuartersInput>;
  connect?: Maybe<YearWhereUniqueInput>;
}

export interface CardCreateWithoutLayoutLGInput {
  id?: Maybe<ID_Input>;
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutMD: LayoutMDCreateOneWithoutCardInput;
  layoutSM: LayoutSMCreateOneWithoutCardInput;
  layoutXS: LayoutXSCreateOneWithoutCardInput;
  grouping: GroupingCreateOneWithoutCardsInput;
}

export interface YearUpdateWithoutQuartersDataInput {
  value?: Maybe<Int>;
  months?: Maybe<MonthUpdateManyWithoutYearInput>;
  weeks?: Maybe<WeekUpdateManyWithoutYearInput>;
}

export interface GroupingCreateWithoutLayoutSMsInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard: DashboardCreateOneWithoutGroupingsInput;
  chips?: Maybe<GroupingCreatechipsInput>;
  cards?: Maybe<CardCreateManyWithoutGroupingInput>;
  layoutLGs?: Maybe<LayoutLGCreateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDCreateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSCreateManyWithoutGroupingInput>;
}

export interface WeekUpdateManyWithoutYearInput {
  create?: Maybe<WeekCreateWithoutYearInput[] | WeekCreateWithoutYearInput>;
  delete?: Maybe<WeekWhereUniqueInput[] | WeekWhereUniqueInput>;
  connect?: Maybe<WeekWhereUniqueInput[] | WeekWhereUniqueInput>;
  set?: Maybe<WeekWhereUniqueInput[] | WeekWhereUniqueInput>;
  disconnect?: Maybe<WeekWhereUniqueInput[] | WeekWhereUniqueInput>;
  update?: Maybe<
    | WeekUpdateWithWhereUniqueWithoutYearInput[]
    | WeekUpdateWithWhereUniqueWithoutYearInput
  >;
  upsert?: Maybe<
    | WeekUpsertWithWhereUniqueWithoutYearInput[]
    | WeekUpsertWithWhereUniqueWithoutYearInput
  >;
  deleteMany?: Maybe<WeekScalarWhereInput[] | WeekScalarWhereInput>;
  updateMany?: Maybe<
    WeekUpdateManyWithWhereNestedInput[] | WeekUpdateManyWithWhereNestedInput
  >;
}

export interface CardCreateWithoutLayoutMDInput {
  id?: Maybe<ID_Input>;
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutLG: LayoutLGCreateOneWithoutCardInput;
  layoutSM: LayoutSMCreateOneWithoutCardInput;
  layoutXS: LayoutXSCreateOneWithoutCardInput;
  grouping: GroupingCreateOneWithoutCardsInput;
}

export interface WeekUpdateWithWhereUniqueWithoutYearInput {
  where: WeekWhereUniqueInput;
  data: WeekUpdateWithoutYearDataInput;
}

export interface GroupingCreateWithoutLayoutXSsInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard: DashboardCreateOneWithoutGroupingsInput;
  chips?: Maybe<GroupingCreatechipsInput>;
  cards?: Maybe<CardCreateManyWithoutGroupingInput>;
  layoutLGs?: Maybe<LayoutLGCreateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDCreateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMCreateManyWithoutGroupingInput>;
}

export interface WeekUpdateWithoutYearDataInput {
  value?: Maybe<Int>;
  weekYear?: Maybe<String>;
  days?: Maybe<DayUpdateManyWithoutWeekInput>;
}

export interface CardCreateWithoutLayoutSMInput {
  id?: Maybe<ID_Input>;
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutLG: LayoutLGCreateOneWithoutCardInput;
  layoutMD: LayoutMDCreateOneWithoutCardInput;
  layoutXS: LayoutXSCreateOneWithoutCardInput;
  grouping: GroupingCreateOneWithoutCardsInput;
}

export interface DayUpdateManyWithoutWeekInput {
  create?: Maybe<DayCreateWithoutWeekInput[] | DayCreateWithoutWeekInput>;
  delete?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  connect?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  set?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  disconnect?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  update?: Maybe<
    | DayUpdateWithWhereUniqueWithoutWeekInput[]
    | DayUpdateWithWhereUniqueWithoutWeekInput
  >;
  upsert?: Maybe<
    | DayUpsertWithWhereUniqueWithoutWeekInput[]
    | DayUpsertWithWhereUniqueWithoutWeekInput
  >;
  deleteMany?: Maybe<DayScalarWhereInput[] | DayScalarWhereInput>;
  updateMany?: Maybe<
    DayUpdateManyWithWhereNestedInput[] | DayUpdateManyWithWhereNestedInput
  >;
}

export interface LayoutXSCreateWithoutGroupingInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  card: CardCreateOneWithoutLayoutXSInput;
}

export interface DayUpdateWithWhereUniqueWithoutWeekInput {
  where: DayWhereUniqueInput;
  data: DayUpdateWithoutWeekDataInput;
}

export interface LayoutLGUpdateOneRequiredWithoutCardInput {
  create?: Maybe<LayoutLGCreateWithoutCardInput>;
  update?: Maybe<LayoutLGUpdateWithoutCardDataInput>;
  upsert?: Maybe<LayoutLGUpsertWithoutCardInput>;
  connect?: Maybe<LayoutLGWhereUniqueInput>;
}

export interface DayUpdateWithoutWeekDataInput {
  value?: Maybe<Int>;
  dayMonthYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredInput>;
  quarter?: Maybe<QuarterUpdateOneRequiredWithoutDaysInput>;
  month?: Maybe<MonthUpdateOneRequiredWithoutDaysInput>;
  hours?: Maybe<HourUpdateManyWithoutDayInput>;
  items?: Maybe<ItemUpdateManyWithoutDayInput>;
}

export interface DashboardUpdateOneRequiredWithoutGroupingsInput {
  create?: Maybe<DashboardCreateWithoutGroupingsInput>;
  update?: Maybe<DashboardUpdateWithoutGroupingsDataInput>;
  upsert?: Maybe<DashboardUpsertWithoutGroupingsInput>;
  connect?: Maybe<DashboardWhereUniqueInput>;
}

export interface MonthUpdateOneRequiredWithoutDaysInput {
  create?: Maybe<MonthCreateWithoutDaysInput>;
  update?: Maybe<MonthUpdateWithoutDaysDataInput>;
  upsert?: Maybe<MonthUpsertWithoutDaysInput>;
  connect?: Maybe<MonthWhereUniqueInput>;
}

export interface CardUpdateManyWithoutGroupingInput {
  create?: Maybe<
    CardCreateWithoutGroupingInput[] | CardCreateWithoutGroupingInput
  >;
  delete?: Maybe<CardWhereUniqueInput[] | CardWhereUniqueInput>;
  connect?: Maybe<CardWhereUniqueInput[] | CardWhereUniqueInput>;
  set?: Maybe<CardWhereUniqueInput[] | CardWhereUniqueInput>;
  disconnect?: Maybe<CardWhereUniqueInput[] | CardWhereUniqueInput>;
  update?: Maybe<
    | CardUpdateWithWhereUniqueWithoutGroupingInput[]
    | CardUpdateWithWhereUniqueWithoutGroupingInput
  >;
  upsert?: Maybe<
    | CardUpsertWithWhereUniqueWithoutGroupingInput[]
    | CardUpsertWithWhereUniqueWithoutGroupingInput
  >;
  deleteMany?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
  updateMany?: Maybe<
    CardUpdateManyWithWhereNestedInput[] | CardUpdateManyWithWhereNestedInput
  >;
}

export interface MonthUpdateWithoutDaysDataInput {
  value?: Maybe<Int>;
  monthYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredWithoutMonthsInput>;
}

export interface LayoutMDUpdateWithoutCardDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutLayoutMDsInput>;
}

export interface YearUpdateOneRequiredWithoutMonthsInput {
  create?: Maybe<YearCreateWithoutMonthsInput>;
  update?: Maybe<YearUpdateWithoutMonthsDataInput>;
  upsert?: Maybe<YearUpsertWithoutMonthsInput>;
  connect?: Maybe<YearWhereUniqueInput>;
}

export interface LayoutLGUpdateWithWhereUniqueWithoutGroupingInput {
  where: LayoutLGWhereUniqueInput;
  data: LayoutLGUpdateWithoutGroupingDataInput;
}

export interface YearUpdateWithoutMonthsDataInput {
  value?: Maybe<Int>;
  quarters?: Maybe<QuarterUpdateManyWithoutYearInput>;
  weeks?: Maybe<WeekUpdateManyWithoutYearInput>;
}

export interface LayoutSMUpdateOneRequiredWithoutCardInput {
  create?: Maybe<LayoutSMCreateWithoutCardInput>;
  update?: Maybe<LayoutSMUpdateWithoutCardDataInput>;
  upsert?: Maybe<LayoutSMUpsertWithoutCardInput>;
  connect?: Maybe<LayoutSMWhereUniqueInput>;
}

export interface YearUpsertWithoutMonthsInput {
  update: YearUpdateWithoutMonthsDataInput;
  create: YearCreateWithoutMonthsInput;
}

export interface LayoutMDUpdateManyWithoutGroupingInput {
  create?: Maybe<
    LayoutMDCreateWithoutGroupingInput[] | LayoutMDCreateWithoutGroupingInput
  >;
  delete?: Maybe<LayoutMDWhereUniqueInput[] | LayoutMDWhereUniqueInput>;
  connect?: Maybe<LayoutMDWhereUniqueInput[] | LayoutMDWhereUniqueInput>;
  set?: Maybe<LayoutMDWhereUniqueInput[] | LayoutMDWhereUniqueInput>;
  disconnect?: Maybe<LayoutMDWhereUniqueInput[] | LayoutMDWhereUniqueInput>;
  update?: Maybe<
    | LayoutMDUpdateWithWhereUniqueWithoutGroupingInput[]
    | LayoutMDUpdateWithWhereUniqueWithoutGroupingInput
  >;
  upsert?: Maybe<
    | LayoutMDUpsertWithWhereUniqueWithoutGroupingInput[]
    | LayoutMDUpsertWithWhereUniqueWithoutGroupingInput
  >;
  deleteMany?: Maybe<LayoutMDScalarWhereInput[] | LayoutMDScalarWhereInput>;
  updateMany?: Maybe<
    | LayoutMDUpdateManyWithWhereNestedInput[]
    | LayoutMDUpdateManyWithWhereNestedInput
  >;
}

export interface MonthUpsertWithoutDaysInput {
  update: MonthUpdateWithoutDaysDataInput;
  create: MonthCreateWithoutDaysInput;
}

export interface CardUpdateWithoutLayoutMDDataInput {
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutLG?: Maybe<LayoutLGUpdateOneRequiredWithoutCardInput>;
  layoutSM?: Maybe<LayoutSMUpdateOneRequiredWithoutCardInput>;
  layoutXS?: Maybe<LayoutXSUpdateOneRequiredWithoutCardInput>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutCardsInput>;
}

export interface HourUpdateManyWithoutDayInput {
  create?: Maybe<HourCreateWithoutDayInput[] | HourCreateWithoutDayInput>;
  delete?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  connect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  set?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  disconnect?: Maybe<HourWhereUniqueInput[] | HourWhereUniqueInput>;
  update?: Maybe<
    | HourUpdateWithWhereUniqueWithoutDayInput[]
    | HourUpdateWithWhereUniqueWithoutDayInput
  >;
  upsert?: Maybe<
    | HourUpsertWithWhereUniqueWithoutDayInput[]
    | HourUpsertWithWhereUniqueWithoutDayInput
  >;
  deleteMany?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  updateMany?: Maybe<
    HourUpdateManyWithWhereNestedInput[] | HourUpdateManyWithWhereNestedInput
  >;
}

export interface GroupingUpdateWithoutLayoutXSsDataInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard?: Maybe<DashboardUpdateOneRequiredWithoutGroupingsInput>;
  chips?: Maybe<GroupingUpdatechipsInput>;
  cards?: Maybe<CardUpdateManyWithoutGroupingInput>;
  layoutLGs?: Maybe<LayoutLGUpdateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDUpdateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMUpdateManyWithoutGroupingInput>;
}

export interface HourUpdateWithWhereUniqueWithoutDayInput {
  where: HourWhereUniqueInput;
  data: HourUpdateWithoutDayDataInput;
}

export interface CardUpdateOneRequiredWithoutLayoutSMInput {
  create?: Maybe<CardCreateWithoutLayoutSMInput>;
  update?: Maybe<CardUpdateWithoutLayoutSMDataInput>;
  upsert?: Maybe<CardUpsertWithoutLayoutSMInput>;
  connect?: Maybe<CardWhereUniqueInput>;
}

export interface HourUpdateWithoutDayDataInput {
  value?: Maybe<Int>;
  hourDayMonthYear?: Maybe<String>;
  items?: Maybe<ItemUpdateManyWithoutHourInput>;
}

export interface LayoutXSUpdateManyWithoutGroupingInput {
  create?: Maybe<
    LayoutXSCreateWithoutGroupingInput[] | LayoutXSCreateWithoutGroupingInput
  >;
  delete?: Maybe<LayoutXSWhereUniqueInput[] | LayoutXSWhereUniqueInput>;
  connect?: Maybe<LayoutXSWhereUniqueInput[] | LayoutXSWhereUniqueInput>;
  set?: Maybe<LayoutXSWhereUniqueInput[] | LayoutXSWhereUniqueInput>;
  disconnect?: Maybe<LayoutXSWhereUniqueInput[] | LayoutXSWhereUniqueInput>;
  update?: Maybe<
    | LayoutXSUpdateWithWhereUniqueWithoutGroupingInput[]
    | LayoutXSUpdateWithWhereUniqueWithoutGroupingInput
  >;
  upsert?: Maybe<
    | LayoutXSUpsertWithWhereUniqueWithoutGroupingInput[]
    | LayoutXSUpsertWithWhereUniqueWithoutGroupingInput
  >;
  deleteMany?: Maybe<LayoutXSScalarWhereInput[] | LayoutXSScalarWhereInput>;
  updateMany?: Maybe<
    | LayoutXSUpdateManyWithWhereNestedInput[]
    | LayoutXSUpdateManyWithWhereNestedInput
  >;
}

export interface ItemUpdateManyWithoutHourInput {
  create?: Maybe<ItemCreateWithoutHourInput[] | ItemCreateWithoutHourInput>;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutHourInput[]
    | ItemUpdateWithWhereUniqueWithoutHourInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutHourInput[]
    | ItemUpsertWithWhereUniqueWithoutHourInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface EntitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EntityWhereInput>;
  AND?: Maybe<EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput>;
  OR?: Maybe<EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput>;
  NOT?: Maybe<EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput>;
}

export interface ItemUpdateWithWhereUniqueWithoutHourInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutHourDataInput;
}

export type DayWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  dayMonthYear?: Maybe<String>;
}>;

export interface ItemUpdateWithoutHourDataInput {
  type?: Maybe<ItemType>;
  alertID?: Maybe<Int>;
  logID?: Maybe<String>;
  triggerTime?: Maybe<String>;
  name?: Maybe<String>;
  message?: Maybe<String>;
  level?: Maybe<Level>;
  source?: Maybe<Source>;
  trigger?: Maybe<EntityUpdateOneRequiredWithoutItemsInput>;
  day?: Maybe<DayUpdateOneRequiredWithoutItemsInput>;
}

export interface HourWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  hourDayMonthYear?: Maybe<String>;
  hourDayMonthYear_not?: Maybe<String>;
  hourDayMonthYear_in?: Maybe<String[] | String>;
  hourDayMonthYear_not_in?: Maybe<String[] | String>;
  hourDayMonthYear_lt?: Maybe<String>;
  hourDayMonthYear_lte?: Maybe<String>;
  hourDayMonthYear_gt?: Maybe<String>;
  hourDayMonthYear_gte?: Maybe<String>;
  hourDayMonthYear_contains?: Maybe<String>;
  hourDayMonthYear_not_contains?: Maybe<String>;
  hourDayMonthYear_starts_with?: Maybe<String>;
  hourDayMonthYear_not_starts_with?: Maybe<String>;
  hourDayMonthYear_ends_with?: Maybe<String>;
  hourDayMonthYear_not_ends_with?: Maybe<String>;
  day?: Maybe<DayWhereInput>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  AND?: Maybe<HourWhereInput[] | HourWhereInput>;
  OR?: Maybe<HourWhereInput[] | HourWhereInput>;
  NOT?: Maybe<HourWhereInput[] | HourWhereInput>;
}

export interface EntityUpdateOneRequiredWithoutItemsInput {
  create?: Maybe<EntityCreateWithoutItemsInput>;
  update?: Maybe<EntityUpdateWithoutItemsDataInput>;
  upsert?: Maybe<EntityUpsertWithoutItemsInput>;
  connect?: Maybe<EntityWhereUniqueInput>;
}

export interface WeekUpdateInput {
  value?: Maybe<Int>;
  weekYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredWithoutWeeksInput>;
  days?: Maybe<DayUpdateManyWithoutWeekInput>;
}

export interface EntityUpdateWithoutItemsDataInput {
  entityID?: Maybe<String>;
  name?: Maybe<String>;
  linkForEntity?: Maybe<String>;
  type?: Maybe<EntityType>;
  source?: Maybe<Source>;
  parent?: Maybe<EntityUpdateOneWithoutParentInput>;
}

export interface MonthSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MonthWhereInput>;
  AND?: Maybe<MonthSubscriptionWhereInput[] | MonthSubscriptionWhereInput>;
  OR?: Maybe<MonthSubscriptionWhereInput[] | MonthSubscriptionWhereInput>;
  NOT?: Maybe<MonthSubscriptionWhereInput[] | MonthSubscriptionWhereInput>;
}

export interface EntityUpdateOneWithoutParentInput {
  create?: Maybe<EntityCreateWithoutParentInput>;
  update?: Maybe<EntityUpdateWithoutParentDataInput>;
  upsert?: Maybe<EntityUpsertWithoutParentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EntityWhereUniqueInput>;
}

export interface LayoutXSUpdateInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  card?: Maybe<CardUpdateOneRequiredWithoutLayoutXSInput>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutLayoutXSsInput>;
}

export interface EntityUpdateWithoutParentDataInput {
  entityID?: Maybe<String>;
  name?: Maybe<String>;
  linkForEntity?: Maybe<String>;
  type?: Maybe<EntityType>;
  source?: Maybe<Source>;
  items?: Maybe<ItemUpdateManyWithoutTriggerInput>;
}

export interface LayoutMDUpdateInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  card?: Maybe<CardUpdateOneRequiredWithoutLayoutMDInput>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutLayoutMDsInput>;
}

export interface ItemUpdateManyWithoutTriggerInput {
  create?: Maybe<
    ItemCreateWithoutTriggerInput[] | ItemCreateWithoutTriggerInput
  >;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutTriggerInput[]
    | ItemUpdateWithWhereUniqueWithoutTriggerInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutTriggerInput[]
    | ItemUpsertWithWhereUniqueWithoutTriggerInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface ItemUpdateInput {
  type?: Maybe<ItemType>;
  alertID?: Maybe<Int>;
  logID?: Maybe<String>;
  triggerTime?: Maybe<String>;
  name?: Maybe<String>;
  message?: Maybe<String>;
  level?: Maybe<Level>;
  source?: Maybe<Source>;
  trigger?: Maybe<EntityUpdateOneRequiredWithoutItemsInput>;
  hour?: Maybe<HourUpdateOneRequiredWithoutItemsInput>;
  day?: Maybe<DayUpdateOneRequiredWithoutItemsInput>;
}

export interface ItemUpdateWithWhereUniqueWithoutTriggerInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutTriggerDataInput;
}

export interface GroupingUpdateInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard?: Maybe<DashboardUpdateOneRequiredWithoutGroupingsInput>;
  chips?: Maybe<GroupingUpdatechipsInput>;
  cards?: Maybe<CardUpdateManyWithoutGroupingInput>;
  layoutLGs?: Maybe<LayoutLGUpdateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDUpdateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMUpdateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSUpdateManyWithoutGroupingInput>;
}

export interface ItemUpdateWithoutTriggerDataInput {
  type?: Maybe<ItemType>;
  alertID?: Maybe<Int>;
  logID?: Maybe<String>;
  triggerTime?: Maybe<String>;
  name?: Maybe<String>;
  message?: Maybe<String>;
  level?: Maybe<Level>;
  source?: Maybe<Source>;
  hour?: Maybe<HourUpdateOneRequiredWithoutItemsInput>;
  day?: Maybe<DayUpdateOneRequiredWithoutItemsInput>;
}

export interface YearUpsertNestedInput {
  update: YearUpdateDataInput;
  create: YearCreateInput;
}

export interface HourUpdateOneRequiredWithoutItemsInput {
  create?: Maybe<HourCreateWithoutItemsInput>;
  update?: Maybe<HourUpdateWithoutItemsDataInput>;
  upsert?: Maybe<HourUpsertWithoutItemsInput>;
  connect?: Maybe<HourWhereUniqueInput>;
}

export interface WeekUpsertWithoutDaysInput {
  update: WeekUpdateWithoutDaysDataInput;
  create: WeekCreateWithoutDaysInput;
}

export interface HourUpdateWithoutItemsDataInput {
  value?: Maybe<Int>;
  hourDayMonthYear?: Maybe<String>;
  day?: Maybe<DayUpdateOneRequiredWithoutHoursInput>;
}

export interface GroupingCreatechipsInput {
  set?: Maybe<String[] | String>;
}

export interface DayUpdateOneRequiredWithoutHoursInput {
  create?: Maybe<DayCreateWithoutHoursInput>;
  update?: Maybe<DayUpdateWithoutHoursDataInput>;
  upsert?: Maybe<DayUpsertWithoutHoursInput>;
  connect?: Maybe<DayWhereUniqueInput>;
}

export interface LayoutLGCreateWithoutGroupingInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  card: CardCreateOneWithoutLayoutLGInput;
}

export interface DayUpdateWithoutHoursDataInput {
  value?: Maybe<Int>;
  dayMonthYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredInput>;
  quarter?: Maybe<QuarterUpdateOneRequiredWithoutDaysInput>;
  week?: Maybe<WeekUpdateOneRequiredWithoutDaysInput>;
  month?: Maybe<MonthUpdateOneRequiredWithoutDaysInput>;
  items?: Maybe<ItemUpdateManyWithoutDayInput>;
}

export interface LayoutMDCreateWithoutGroupingInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  card: CardCreateOneWithoutLayoutMDInput;
}

export interface ItemUpdateManyWithoutDayInput {
  create?: Maybe<ItemCreateWithoutDayInput[] | ItemCreateWithoutDayInput>;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutDayInput[]
    | ItemUpdateWithWhereUniqueWithoutDayInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutDayInput[]
    | ItemUpsertWithWhereUniqueWithoutDayInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface LayoutSMCreateWithoutGroupingInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  card: CardCreateOneWithoutLayoutSMInput;
}

export interface ItemUpdateWithWhereUniqueWithoutDayInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutDayDataInput;
}

export interface CardCreateWithoutLayoutXSInput {
  id?: Maybe<ID_Input>;
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutLG: LayoutLGCreateOneWithoutCardInput;
  layoutMD: LayoutMDCreateOneWithoutCardInput;
  layoutSM: LayoutSMCreateOneWithoutCardInput;
  grouping: GroupingCreateOneWithoutCardsInput;
}

export interface ItemUpdateWithoutDayDataInput {
  type?: Maybe<ItemType>;
  alertID?: Maybe<Int>;
  logID?: Maybe<String>;
  triggerTime?: Maybe<String>;
  name?: Maybe<String>;
  message?: Maybe<String>;
  level?: Maybe<Level>;
  source?: Maybe<Source>;
  trigger?: Maybe<EntityUpdateOneRequiredWithoutItemsInput>;
  hour?: Maybe<HourUpdateOneRequiredWithoutItemsInput>;
}

export interface DashboardUpsertWithoutGroupingsInput {
  update: DashboardUpdateWithoutGroupingsDataInput;
  create: DashboardCreateWithoutGroupingsInput;
}

export interface ItemUpsertWithWhereUniqueWithoutDayInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutDayDataInput;
  create: ItemCreateWithoutDayInput;
}

export interface GroupingUpdateWithoutLayoutMDsDataInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard?: Maybe<DashboardUpdateOneRequiredWithoutGroupingsInput>;
  chips?: Maybe<GroupingUpdatechipsInput>;
  cards?: Maybe<CardUpdateManyWithoutGroupingInput>;
  layoutLGs?: Maybe<LayoutLGUpdateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMUpdateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSUpdateManyWithoutGroupingInput>;
}

export interface ItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<ItemType>;
  type_not?: Maybe<ItemType>;
  type_in?: Maybe<ItemType[] | ItemType>;
  type_not_in?: Maybe<ItemType[] | ItemType>;
  alertID?: Maybe<Int>;
  alertID_not?: Maybe<Int>;
  alertID_in?: Maybe<Int[] | Int>;
  alertID_not_in?: Maybe<Int[] | Int>;
  alertID_lt?: Maybe<Int>;
  alertID_lte?: Maybe<Int>;
  alertID_gt?: Maybe<Int>;
  alertID_gte?: Maybe<Int>;
  logID?: Maybe<String>;
  logID_not?: Maybe<String>;
  logID_in?: Maybe<String[] | String>;
  logID_not_in?: Maybe<String[] | String>;
  logID_lt?: Maybe<String>;
  logID_lte?: Maybe<String>;
  logID_gt?: Maybe<String>;
  logID_gte?: Maybe<String>;
  logID_contains?: Maybe<String>;
  logID_not_contains?: Maybe<String>;
  logID_starts_with?: Maybe<String>;
  logID_not_starts_with?: Maybe<String>;
  logID_ends_with?: Maybe<String>;
  logID_not_ends_with?: Maybe<String>;
  triggerTime?: Maybe<String>;
  triggerTime_not?: Maybe<String>;
  triggerTime_in?: Maybe<String[] | String>;
  triggerTime_not_in?: Maybe<String[] | String>;
  triggerTime_lt?: Maybe<String>;
  triggerTime_lte?: Maybe<String>;
  triggerTime_gt?: Maybe<String>;
  triggerTime_gte?: Maybe<String>;
  triggerTime_contains?: Maybe<String>;
  triggerTime_not_contains?: Maybe<String>;
  triggerTime_starts_with?: Maybe<String>;
  triggerTime_not_starts_with?: Maybe<String>;
  triggerTime_ends_with?: Maybe<String>;
  triggerTime_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  level?: Maybe<Level>;
  level_not?: Maybe<Level>;
  level_in?: Maybe<Level[] | Level>;
  level_not_in?: Maybe<Level[] | Level>;
  source?: Maybe<Source>;
  source_not?: Maybe<Source>;
  source_in?: Maybe<Source[] | Source>;
  source_not_in?: Maybe<Source[] | Source>;
  AND?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  OR?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  NOT?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
}

export interface GroupingUpdateOneRequiredWithoutLayoutSMsInput {
  create?: Maybe<GroupingCreateWithoutLayoutSMsInput>;
  update?: Maybe<GroupingUpdateWithoutLayoutSMsDataInput>;
  upsert?: Maybe<GroupingUpsertWithoutLayoutSMsInput>;
  connect?: Maybe<GroupingWhereUniqueInput>;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface LayoutXSUpdateWithoutCardDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutLayoutXSsInput>;
}

export interface ItemUpdateManyDataInput {
  type?: Maybe<ItemType>;
  alertID?: Maybe<Int>;
  logID?: Maybe<String>;
  triggerTime?: Maybe<String>;
  name?: Maybe<String>;
  message?: Maybe<String>;
  level?: Maybe<Level>;
  source?: Maybe<Source>;
}

export interface GroupingUpdateOneRequiredWithoutCardsInput {
  create?: Maybe<GroupingCreateWithoutCardsInput>;
  update?: Maybe<GroupingUpdateWithoutCardsDataInput>;
  upsert?: Maybe<GroupingUpsertWithoutCardsInput>;
  connect?: Maybe<GroupingWhereUniqueInput>;
}

export interface DayUpsertWithoutHoursInput {
  update: DayUpdateWithoutHoursDataInput;
  create: DayCreateWithoutHoursInput;
}

export interface LayoutLGSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LayoutLGWhereInput>;
  AND?: Maybe<
    LayoutLGSubscriptionWhereInput[] | LayoutLGSubscriptionWhereInput
  >;
  OR?: Maybe<LayoutLGSubscriptionWhereInput[] | LayoutLGSubscriptionWhereInput>;
  NOT?: Maybe<
    LayoutLGSubscriptionWhereInput[] | LayoutLGSubscriptionWhereInput
  >;
}

export interface HourUpsertWithoutItemsInput {
  update: HourUpdateWithoutItemsDataInput;
  create: HourCreateWithoutItemsInput;
}

export interface LayoutMDWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  w?: Maybe<Int>;
  w_not?: Maybe<Int>;
  w_in?: Maybe<Int[] | Int>;
  w_not_in?: Maybe<Int[] | Int>;
  w_lt?: Maybe<Int>;
  w_lte?: Maybe<Int>;
  w_gt?: Maybe<Int>;
  w_gte?: Maybe<Int>;
  h?: Maybe<Int>;
  h_not?: Maybe<Int>;
  h_in?: Maybe<Int[] | Int>;
  h_not_in?: Maybe<Int[] | Int>;
  h_lt?: Maybe<Int>;
  h_lte?: Maybe<Int>;
  h_gt?: Maybe<Int>;
  h_gte?: Maybe<Int>;
  card?: Maybe<CardWhereInput>;
  grouping?: Maybe<GroupingWhereInput>;
  AND?: Maybe<LayoutMDWhereInput[] | LayoutMDWhereInput>;
  OR?: Maybe<LayoutMDWhereInput[] | LayoutMDWhereInput>;
  NOT?: Maybe<LayoutMDWhereInput[] | LayoutMDWhereInput>;
}

export interface DayUpdateOneRequiredWithoutItemsInput {
  create?: Maybe<DayCreateWithoutItemsInput>;
  update?: Maybe<DayUpdateWithoutItemsDataInput>;
  upsert?: Maybe<DayUpsertWithoutItemsInput>;
  connect?: Maybe<DayWhereUniqueInput>;
}

export interface MonthCreateInput {
  id?: Maybe<ID_Input>;
  value: Int;
  monthYear: String;
  year: YearCreateOneWithoutMonthsInput;
  days?: Maybe<DayCreateManyWithoutMonthInput>;
}

export interface DayUpdateWithoutItemsDataInput {
  value?: Maybe<Int>;
  dayMonthYear?: Maybe<String>;
  year?: Maybe<YearUpdateOneRequiredInput>;
  quarter?: Maybe<QuarterUpdateOneRequiredWithoutDaysInput>;
  week?: Maybe<WeekUpdateOneRequiredWithoutDaysInput>;
  month?: Maybe<MonthUpdateOneRequiredWithoutDaysInput>;
  hours?: Maybe<HourUpdateManyWithoutDayInput>;
}

export interface LayoutLGUpdateInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  card?: Maybe<CardUpdateOneRequiredWithoutLayoutLGInput>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutLayoutLGsInput>;
}

export interface DayUpsertWithoutItemsInput {
  update: DayUpdateWithoutItemsDataInput;
  create: DayCreateWithoutItemsInput;
}

export interface EntityUpdateInput {
  entityID?: Maybe<String>;
  name?: Maybe<String>;
  linkForEntity?: Maybe<String>;
  type?: Maybe<EntityType>;
  source?: Maybe<Source>;
  parent?: Maybe<EntityUpdateOneWithoutParentInput>;
  items?: Maybe<ItemUpdateManyWithoutTriggerInput>;
}

export interface ItemUpsertWithWhereUniqueWithoutTriggerInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutTriggerDataInput;
  create: ItemCreateWithoutTriggerInput;
}

export interface WeekSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WeekWhereInput>;
  AND?: Maybe<WeekSubscriptionWhereInput[] | WeekSubscriptionWhereInput>;
  OR?: Maybe<WeekSubscriptionWhereInput[] | WeekSubscriptionWhereInput>;
  NOT?: Maybe<WeekSubscriptionWhereInput[] | WeekSubscriptionWhereInput>;
}

export interface EntityUpsertWithoutParentInput {
  update: EntityUpdateWithoutParentDataInput;
  create: EntityCreateWithoutParentInput;
}

export interface LayoutMDCreateWithoutCardInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  grouping: GroupingCreateOneWithoutLayoutMDsInput;
}

export interface EntityUpsertWithoutItemsInput {
  update: EntityUpdateWithoutItemsDataInput;
  create: EntityCreateWithoutItemsInput;
}

export interface LayoutXSCreateWithoutCardInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  grouping: GroupingCreateOneWithoutLayoutXSsInput;
}

export interface ItemUpsertWithWhereUniqueWithoutHourInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutHourDataInput;
  create: ItemCreateWithoutHourInput;
}

export interface GroupingUpdateOneRequiredWithoutLayoutLGsInput {
  create?: Maybe<GroupingCreateWithoutLayoutLGsInput>;
  update?: Maybe<GroupingUpdateWithoutLayoutLGsDataInput>;
  upsert?: Maybe<GroupingUpsertWithoutLayoutLGsInput>;
  connect?: Maybe<GroupingWhereUniqueInput>;
}

export interface HourUpsertWithWhereUniqueWithoutDayInput {
  where: HourWhereUniqueInput;
  update: HourUpdateWithoutDayDataInput;
  create: HourCreateWithoutDayInput;
}

export interface CardUpdateOneRequiredWithoutLayoutLGInput {
  create?: Maybe<CardCreateWithoutLayoutLGInput>;
  update?: Maybe<CardUpdateWithoutLayoutLGDataInput>;
  upsert?: Maybe<CardUpsertWithoutLayoutLGInput>;
  connect?: Maybe<CardWhereUniqueInput>;
}

export interface HourScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  hourDayMonthYear?: Maybe<String>;
  hourDayMonthYear_not?: Maybe<String>;
  hourDayMonthYear_in?: Maybe<String[] | String>;
  hourDayMonthYear_not_in?: Maybe<String[] | String>;
  hourDayMonthYear_lt?: Maybe<String>;
  hourDayMonthYear_lte?: Maybe<String>;
  hourDayMonthYear_gt?: Maybe<String>;
  hourDayMonthYear_gte?: Maybe<String>;
  hourDayMonthYear_contains?: Maybe<String>;
  hourDayMonthYear_not_contains?: Maybe<String>;
  hourDayMonthYear_starts_with?: Maybe<String>;
  hourDayMonthYear_not_starts_with?: Maybe<String>;
  hourDayMonthYear_ends_with?: Maybe<String>;
  hourDayMonthYear_not_ends_with?: Maybe<String>;
  AND?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  OR?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  NOT?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
}

export interface LayoutSMUpdateWithWhereUniqueWithoutGroupingInput {
  where: LayoutSMWhereUniqueInput;
  data: LayoutSMUpdateWithoutGroupingDataInput;
}

export interface HourUpdateManyWithWhereNestedInput {
  where: HourScalarWhereInput;
  data: HourUpdateManyDataInput;
}

export interface YearWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  quarters_every?: Maybe<QuarterWhereInput>;
  quarters_some?: Maybe<QuarterWhereInput>;
  quarters_none?: Maybe<QuarterWhereInput>;
  months_every?: Maybe<MonthWhereInput>;
  months_some?: Maybe<MonthWhereInput>;
  months_none?: Maybe<MonthWhereInput>;
  weeks_every?: Maybe<WeekWhereInput>;
  weeks_some?: Maybe<WeekWhereInput>;
  weeks_none?: Maybe<WeekWhereInput>;
  AND?: Maybe<YearWhereInput[] | YearWhereInput>;
  OR?: Maybe<YearWhereInput[] | YearWhereInput>;
  NOT?: Maybe<YearWhereInput[] | YearWhereInput>;
}

export interface HourUpdateManyDataInput {
  value?: Maybe<Int>;
  hourDayMonthYear?: Maybe<String>;
}

export interface LayoutSMUpdateInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  card?: Maybe<CardUpdateOneRequiredWithoutLayoutSMInput>;
  grouping?: Maybe<GroupingUpdateOneRequiredWithoutLayoutSMsInput>;
}

export interface DayUpsertWithWhereUniqueWithoutWeekInput {
  where: DayWhereUniqueInput;
  update: DayUpdateWithoutWeekDataInput;
  create: DayCreateWithoutWeekInput;
}

export interface QuarterScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  quarterYear?: Maybe<String>;
  quarterYear_not?: Maybe<String>;
  quarterYear_in?: Maybe<String[] | String>;
  quarterYear_not_in?: Maybe<String[] | String>;
  quarterYear_lt?: Maybe<String>;
  quarterYear_lte?: Maybe<String>;
  quarterYear_gt?: Maybe<String>;
  quarterYear_gte?: Maybe<String>;
  quarterYear_contains?: Maybe<String>;
  quarterYear_not_contains?: Maybe<String>;
  quarterYear_starts_with?: Maybe<String>;
  quarterYear_not_starts_with?: Maybe<String>;
  quarterYear_ends_with?: Maybe<String>;
  quarterYear_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuarterScalarWhereInput[] | QuarterScalarWhereInput>;
  OR?: Maybe<QuarterScalarWhereInput[] | QuarterScalarWhereInput>;
  NOT?: Maybe<QuarterScalarWhereInput[] | QuarterScalarWhereInput>;
}

export interface DayScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  dayMonthYear?: Maybe<String>;
  dayMonthYear_not?: Maybe<String>;
  dayMonthYear_in?: Maybe<String[] | String>;
  dayMonthYear_not_in?: Maybe<String[] | String>;
  dayMonthYear_lt?: Maybe<String>;
  dayMonthYear_lte?: Maybe<String>;
  dayMonthYear_gt?: Maybe<String>;
  dayMonthYear_gte?: Maybe<String>;
  dayMonthYear_contains?: Maybe<String>;
  dayMonthYear_not_contains?: Maybe<String>;
  dayMonthYear_starts_with?: Maybe<String>;
  dayMonthYear_not_starts_with?: Maybe<String>;
  dayMonthYear_ends_with?: Maybe<String>;
  dayMonthYear_not_ends_with?: Maybe<String>;
  AND?: Maybe<DayScalarWhereInput[] | DayScalarWhereInput>;
  OR?: Maybe<DayScalarWhereInput[] | DayScalarWhereInput>;
  NOT?: Maybe<DayScalarWhereInput[] | DayScalarWhereInput>;
}

export interface LayoutSMCreateWithoutCardInput {
  id?: Maybe<ID_Input>;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
  grouping: GroupingCreateOneWithoutLayoutSMsInput;
}

export interface DayUpdateManyWithWhereNestedInput {
  where: DayScalarWhereInput;
  data: DayUpdateManyDataInput;
}

export interface CardUpdateWithoutGroupingDataInput {
  cardType?: Maybe<CardType>;
  title?: Maybe<String>;
  layoutLG?: Maybe<LayoutLGUpdateOneRequiredWithoutCardInput>;
  layoutMD?: Maybe<LayoutMDUpdateOneRequiredWithoutCardInput>;
  layoutSM?: Maybe<LayoutSMUpdateOneRequiredWithoutCardInput>;
  layoutXS?: Maybe<LayoutXSUpdateOneRequiredWithoutCardInput>;
}

export interface DayUpdateManyDataInput {
  value?: Maybe<Int>;
  dayMonthYear?: Maybe<String>;
}

export interface LayoutXSUpdateWithoutGroupingDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  card?: Maybe<CardUpdateOneRequiredWithoutLayoutXSInput>;
}

export interface WeekUpdateManyDataInput {
  value?: Maybe<Int>;
  weekYear?: Maybe<String>;
}

export interface WeekUpdateManyWithWhereNestedInput {
  where: WeekScalarWhereInput;
  data: WeekUpdateManyDataInput;
}

export interface WeekScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  weekYear?: Maybe<String>;
  weekYear_not?: Maybe<String>;
  weekYear_in?: Maybe<String[] | String>;
  weekYear_not_in?: Maybe<String[] | String>;
  weekYear_lt?: Maybe<String>;
  weekYear_lte?: Maybe<String>;
  weekYear_gt?: Maybe<String>;
  weekYear_gte?: Maybe<String>;
  weekYear_contains?: Maybe<String>;
  weekYear_not_contains?: Maybe<String>;
  weekYear_starts_with?: Maybe<String>;
  weekYear_not_starts_with?: Maybe<String>;
  weekYear_ends_with?: Maybe<String>;
  weekYear_not_ends_with?: Maybe<String>;
  AND?: Maybe<WeekScalarWhereInput[] | WeekScalarWhereInput>;
  OR?: Maybe<WeekScalarWhereInput[] | WeekScalarWhereInput>;
  NOT?: Maybe<WeekScalarWhereInput[] | WeekScalarWhereInput>;
}

export interface WeekUpsertWithWhereUniqueWithoutYearInput {
  where: WeekWhereUniqueInput;
  update: WeekUpdateWithoutYearDataInput;
  create: WeekCreateWithoutYearInput;
}

export interface LayoutSMSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LayoutSMWhereInput>;
  AND?: Maybe<
    LayoutSMSubscriptionWhereInput[] | LayoutSMSubscriptionWhereInput
  >;
  OR?: Maybe<LayoutSMSubscriptionWhereInput[] | LayoutSMSubscriptionWhereInput>;
  NOT?: Maybe<
    LayoutSMSubscriptionWhereInput[] | LayoutSMSubscriptionWhereInput
  >;
}

export interface LayoutMDUpdateWithoutGroupingDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  w?: Maybe<Int>;
  h?: Maybe<Int>;
  card?: Maybe<CardUpdateOneRequiredWithoutLayoutMDInput>;
}

export interface GroupingCreateWithoutCardsInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  dashboard: DashboardCreateOneWithoutGroupingsInput;
  chips?: Maybe<GroupingCreatechipsInput>;
  layoutLGs?: Maybe<LayoutLGCreateManyWithoutGroupingInput>;
  layoutMDs?: Maybe<LayoutMDCreateManyWithoutGroupingInput>;
  layoutSMs?: Maybe<LayoutSMCreateManyWithoutGroupingInput>;
  layoutXSs?: Maybe<LayoutXSCreateManyWithoutGroupingInput>;
}

export interface GroupingCreateOneWithoutLayoutLGsInput {
  create?: Maybe<GroupingCreateWithoutLayoutLGsInput>;
  connect?: Maybe<GroupingWhereUniqueInput>;
}

export interface HourUpdateInput {
  value?: Maybe<Int>;
  hourDayMonthYear?: Maybe<String>;
  day?: Maybe<DayUpdateOneRequiredWithoutHoursInput>;
  items?: Maybe<ItemUpdateManyWithoutHourInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Day {
  id: ID_Output;
  value?: Int;
  dayMonthYear: String;
}

export interface DayPromise extends Promise<Day>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  dayMonthYear: () => Promise<String>;
  year: <T = YearPromise>() => T;
  quarter: <T = QuarterPromise>() => T;
  week: <T = WeekPromise>() => T;
  month: <T = MonthPromise>() => T;
  hours: <T = FragmentableArray<Hour>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DaySubscription
  extends Promise<AsyncIterator<Day>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
  dayMonthYear: () => Promise<AsyncIterator<String>>;
  year: <T = YearSubscription>() => T;
  quarter: <T = QuarterSubscription>() => T;
  week: <T = WeekSubscription>() => T;
  month: <T = MonthSubscription>() => T;
  hours: <T = Promise<AsyncIterator<HourSubscription>>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DayNullablePromise extends Promise<Day | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  dayMonthYear: () => Promise<String>;
  year: <T = YearPromise>() => T;
  quarter: <T = QuarterPromise>() => T;
  week: <T = WeekPromise>() => T;
  month: <T = MonthPromise>() => T;
  hours: <T = FragmentableArray<Hour>>(args?: {
    where?: HourWhereInput;
    orderBy?: HourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface YearPreviousValues {
  id: ID_Output;
  value: Int;
}

export interface YearPreviousValuesPromise
  extends Promise<YearPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
}

export interface YearPreviousValuesSubscription
  extends Promise<AsyncIterator<YearPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateDashboard {
  count: Int;
}

export interface AggregateDashboardPromise
  extends Promise<AggregateDashboard>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDashboardSubscription
  extends Promise<AsyncIterator<AggregateDashboard>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateYear {
  count: Int;
}

export interface AggregateYearPromise
  extends Promise<AggregateYear>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateYearSubscription
  extends Promise<AsyncIterator<AggregateYear>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DashboardEdge {
  node: Dashboard;
  cursor: String;
}

export interface DashboardEdgePromise
  extends Promise<DashboardEdge>,
    Fragmentable {
  node: <T = DashboardPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DashboardEdgeSubscription
  extends Promise<AsyncIterator<DashboardEdge>>,
    Fragmentable {
  node: <T = DashboardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface YearConnection {
  pageInfo: PageInfo;
  edges: YearEdge[];
}

export interface YearConnectionPromise
  extends Promise<YearConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<YearEdge>>() => T;
  aggregate: <T = AggregateYearPromise>() => T;
}

export interface YearConnectionSubscription
  extends Promise<AsyncIterator<YearConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<YearEdgeSubscription>>>() => T;
  aggregate: <T = AggregateYearSubscription>() => T;
}

export interface DashboardConnection {
  pageInfo: PageInfo;
  edges: DashboardEdge[];
}

export interface DashboardConnectionPromise
  extends Promise<DashboardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DashboardEdge>>() => T;
  aggregate: <T = AggregateDashboardPromise>() => T;
}

export interface DashboardConnectionSubscription
  extends Promise<AsyncIterator<DashboardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DashboardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDashboardSubscription>() => T;
}

export interface WeekEdge {
  node: Week;
  cursor: String;
}

export interface WeekEdgePromise extends Promise<WeekEdge>, Fragmentable {
  node: <T = WeekPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WeekEdgeSubscription
  extends Promise<AsyncIterator<WeekEdge>>,
    Fragmentable {
  node: <T = WeekSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CardSubscriptionPayload {
  mutation: MutationType;
  node: Card;
  updatedFields: String[];
  previousValues: CardPreviousValues;
}

export interface CardSubscriptionPayloadPromise
  extends Promise<CardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CardPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CardPreviousValuesPromise>() => T;
}

export interface CardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CardPreviousValuesSubscription>() => T;
}

export interface AggregateQuarter {
  count: Int;
}

export interface AggregateQuarterPromise
  extends Promise<AggregateQuarter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuarterSubscription
  extends Promise<AsyncIterator<AggregateQuarter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CardPreviousValues {
  id: ID_Output;
  cardType?: CardType;
  title?: String;
}

export interface CardPreviousValuesPromise
  extends Promise<CardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  cardType: () => Promise<CardType>;
  title: () => Promise<String>;
}

export interface CardPreviousValuesSubscription
  extends Promise<AsyncIterator<CardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  cardType: () => Promise<AsyncIterator<CardType>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface QuarterConnection {
  pageInfo: PageInfo;
  edges: QuarterEdge[];
}

export interface QuarterConnectionPromise
  extends Promise<QuarterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuarterEdge>>() => T;
  aggregate: <T = AggregateQuarterPromise>() => T;
}

export interface QuarterConnectionSubscription
  extends Promise<AsyncIterator<QuarterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuarterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuarterSubscription>() => T;
}

export interface AggregateCard {
  count: Int;
}

export interface AggregateCardPromise
  extends Promise<AggregateCard>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCardSubscription
  extends Promise<AsyncIterator<AggregateCard>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MonthEdge {
  node: Month;
  cursor: String;
}

export interface MonthEdgePromise extends Promise<MonthEdge>, Fragmentable {
  node: <T = MonthPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MonthEdgeSubscription
  extends Promise<AsyncIterator<MonthEdge>>,
    Fragmentable {
  node: <T = MonthSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DashboardSubscriptionPayload {
  mutation: MutationType;
  node: Dashboard;
  updatedFields: String[];
  previousValues: DashboardPreviousValues;
}

export interface DashboardSubscriptionPayloadPromise
  extends Promise<DashboardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DashboardPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DashboardPreviousValuesPromise>() => T;
}

export interface DashboardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DashboardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DashboardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DashboardPreviousValuesSubscription>() => T;
}

export interface AggregateLayoutXS {
  count: Int;
}

export interface AggregateLayoutXSPromise
  extends Promise<AggregateLayoutXS>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLayoutXSSubscription
  extends Promise<AsyncIterator<AggregateLayoutXS>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DashboardPreviousValues {
  id: ID_Output;
  name: String;
}

export interface DashboardPreviousValuesPromise
  extends Promise<DashboardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface DashboardPreviousValuesSubscription
  extends Promise<AsyncIterator<DashboardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface LayoutXSConnection {
  pageInfo: PageInfo;
  edges: LayoutXSEdge[];
}

export interface LayoutXSConnectionPromise
  extends Promise<LayoutXSConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LayoutXSEdge>>() => T;
  aggregate: <T = AggregateLayoutXSPromise>() => T;
}

export interface LayoutXSConnectionSubscription
  extends Promise<AsyncIterator<LayoutXSConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LayoutXSEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLayoutXSSubscription>() => T;
}

export interface CardEdge {
  node: Card;
  cursor: String;
}

export interface CardEdgePromise extends Promise<CardEdge>, Fragmentable {
  node: <T = CardPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CardEdgeSubscription
  extends Promise<AsyncIterator<CardEdge>>,
    Fragmentable {
  node: <T = CardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LayoutSMEdge {
  node: LayoutSM;
  cursor: String;
}

export interface LayoutSMEdgePromise
  extends Promise<LayoutSMEdge>,
    Fragmentable {
  node: <T = LayoutSMPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LayoutSMEdgeSubscription
  extends Promise<AsyncIterator<LayoutSMEdge>>,
    Fragmentable {
  node: <T = LayoutSMSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DaySubscriptionPayload {
  mutation: MutationType;
  node: Day;
  updatedFields: String[];
  previousValues: DayPreviousValues;
}

export interface DaySubscriptionPayloadPromise
  extends Promise<DaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DayPreviousValuesPromise>() => T;
}

export interface DaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DayPreviousValuesSubscription>() => T;
}

export interface AggregateLayoutMD {
  count: Int;
}

export interface AggregateLayoutMDPromise
  extends Promise<AggregateLayoutMD>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLayoutMDSubscription
  extends Promise<AsyncIterator<AggregateLayoutMD>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DayPreviousValues {
  id: ID_Output;
  value?: Int;
  dayMonthYear: String;
}

export interface DayPreviousValuesPromise
  extends Promise<DayPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  dayMonthYear: () => Promise<String>;
}

export interface DayPreviousValuesSubscription
  extends Promise<AsyncIterator<DayPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
  dayMonthYear: () => Promise<AsyncIterator<String>>;
}

export interface LayoutMDConnection {
  pageInfo: PageInfo;
  edges: LayoutMDEdge[];
}

export interface LayoutMDConnectionPromise
  extends Promise<LayoutMDConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LayoutMDEdge>>() => T;
  aggregate: <T = AggregateLayoutMDPromise>() => T;
}

export interface LayoutMDConnectionSubscription
  extends Promise<AsyncIterator<LayoutMDConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LayoutMDEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLayoutMDSubscription>() => T;
}

export interface LayoutMDEdge {
  node: LayoutMD;
  cursor: String;
}

export interface LayoutMDEdgePromise
  extends Promise<LayoutMDEdge>,
    Fragmentable {
  node: <T = LayoutMDPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LayoutMDEdgeSubscription
  extends Promise<AsyncIterator<LayoutMDEdge>>,
    Fragmentable {
  node: <T = LayoutMDSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface WeekSubscriptionPayload {
  mutation: MutationType;
  node: Week;
  updatedFields: String[];
  previousValues: WeekPreviousValues;
}

export interface WeekSubscriptionPayloadPromise
  extends Promise<WeekSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WeekPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WeekPreviousValuesPromise>() => T;
}

export interface WeekSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WeekSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WeekSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WeekPreviousValuesSubscription>() => T;
}

export interface AggregateLayoutLG {
  count: Int;
}

export interface AggregateLayoutLGPromise
  extends Promise<AggregateLayoutLG>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLayoutLGSubscription
  extends Promise<AsyncIterator<AggregateLayoutLG>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LayoutLGEdge {
  node: LayoutLG;
  cursor: String;
}

export interface LayoutLGEdgePromise
  extends Promise<LayoutLGEdge>,
    Fragmentable {
  node: <T = LayoutLGPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LayoutLGEdgeSubscription
  extends Promise<AsyncIterator<LayoutLGEdge>>,
    Fragmentable {
  node: <T = LayoutLGSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LayoutLGConnection {
  pageInfo: PageInfo;
  edges: LayoutLGEdge[];
}

export interface LayoutLGConnectionPromise
  extends Promise<LayoutLGConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LayoutLGEdge>>() => T;
  aggregate: <T = AggregateLayoutLGPromise>() => T;
}

export interface LayoutLGConnectionSubscription
  extends Promise<AsyncIterator<LayoutLGConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LayoutLGEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLayoutLGSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EntitySubscriptionPayload {
  mutation: MutationType;
  node: Entity;
  updatedFields: String[];
  previousValues: EntityPreviousValues;
}

export interface EntitySubscriptionPayloadPromise
  extends Promise<EntitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityPreviousValuesPromise>() => T;
}

export interface EntitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityPreviousValuesSubscription>() => T;
}

export interface AggregateHour {
  count: Int;
}

export interface AggregateHourPromise
  extends Promise<AggregateHour>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHourSubscription
  extends Promise<AsyncIterator<AggregateHour>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityPreviousValues {
  id: ID_Output;
  entityID?: String;
  name?: String;
  linkForEntity?: String;
  type?: EntityType;
  source: Source;
}

export interface EntityPreviousValuesPromise
  extends Promise<EntityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  entityID: () => Promise<String>;
  name: () => Promise<String>;
  linkForEntity: () => Promise<String>;
  type: () => Promise<EntityType>;
  source: () => Promise<Source>;
}

export interface EntityPreviousValuesSubscription
  extends Promise<AsyncIterator<EntityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  entityID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  linkForEntity: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<EntityType>>;
  source: () => Promise<AsyncIterator<Source>>;
}

export interface HourConnection {
  pageInfo: PageInfo;
  edges: HourEdge[];
}

export interface HourConnectionPromise
  extends Promise<HourConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HourEdge>>() => T;
  aggregate: <T = AggregateHourPromise>() => T;
}

export interface HourConnectionSubscription
  extends Promise<AsyncIterator<HourConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HourEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHourSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface GroupingEdge {
  node: Grouping;
  cursor: String;
}

export interface GroupingEdgePromise
  extends Promise<GroupingEdge>,
    Fragmentable {
  node: <T = GroupingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupingEdgeSubscription
  extends Promise<AsyncIterator<GroupingEdge>>,
    Fragmentable {
  node: <T = GroupingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GroupingSubscriptionPayload {
  mutation: MutationType;
  node: Grouping;
  updatedFields: String[];
  previousValues: GroupingPreviousValues;
}

export interface GroupingSubscriptionPayloadPromise
  extends Promise<GroupingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupingPreviousValuesPromise>() => T;
}

export interface GroupingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupingPreviousValuesSubscription>() => T;
}

export interface AggregateEntity {
  count: Int;
}

export interface AggregateEntityPromise
  extends Promise<AggregateEntity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntitySubscription
  extends Promise<AsyncIterator<AggregateEntity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GroupingPreviousValues {
  id: ID_Output;
  title?: String;
  subtitle?: String;
  chips: String[];
}

export interface GroupingPreviousValuesPromise
  extends Promise<GroupingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  chips: () => Promise<String[]>;
}

export interface GroupingPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  chips: () => Promise<AsyncIterator<String[]>>;
}

export interface EntityConnection {
  pageInfo: PageInfo;
  edges: EntityEdge[];
}

export interface EntityConnectionPromise
  extends Promise<EntityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityEdge>>() => T;
  aggregate: <T = AggregateEntityPromise>() => T;
}

export interface EntityConnectionSubscription
  extends Promise<AsyncIterator<EntityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EntityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEntitySubscription>() => T;
}

export interface CardConnection {
  pageInfo: PageInfo;
  edges: CardEdge[];
}

export interface CardConnectionPromise
  extends Promise<CardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CardEdge>>() => T;
  aggregate: <T = AggregateCardPromise>() => T;
}

export interface CardConnectionSubscription
  extends Promise<AsyncIterator<CardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCardSubscription>() => T;
}

export interface DayEdge {
  node: Day;
  cursor: String;
}

export interface DayEdgePromise extends Promise<DayEdge>, Fragmentable {
  node: <T = DayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DayEdgeSubscription
  extends Promise<AsyncIterator<DayEdge>>,
    Fragmentable {
  node: <T = DaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HourSubscriptionPayload {
  mutation: MutationType;
  node: Hour;
  updatedFields: String[];
  previousValues: HourPreviousValues;
}

export interface HourSubscriptionPayloadPromise
  extends Promise<HourSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HourPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HourPreviousValuesPromise>() => T;
}

export interface HourSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HourSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HourSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HourPreviousValuesSubscription>() => T;
}

export interface Entity {
  id: ID_Output;
  entityID?: String;
  name?: String;
  linkForEntity?: String;
  type?: EntityType;
  source: Source;
}

export interface EntityPromise extends Promise<Entity>, Fragmentable {
  id: () => Promise<ID_Output>;
  entityID: () => Promise<String>;
  name: () => Promise<String>;
  linkForEntity: () => Promise<String>;
  type: () => Promise<EntityType>;
  source: () => Promise<Source>;
  parent: <T = EntityPromise>() => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EntitySubscription
  extends Promise<AsyncIterator<Entity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  entityID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  linkForEntity: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<EntityType>>;
  source: () => Promise<AsyncIterator<Source>>;
  parent: <T = EntitySubscription>() => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EntityNullablePromise
  extends Promise<Entity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  entityID: () => Promise<String>;
  name: () => Promise<String>;
  linkForEntity: () => Promise<String>;
  type: () => Promise<EntityType>;
  source: () => Promise<Source>;
  parent: <T = EntityPromise>() => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface HourPreviousValues {
  id: ID_Output;
  value: Int;
  hourDayMonthYear: String;
}

export interface HourPreviousValuesPromise
  extends Promise<HourPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  hourDayMonthYear: () => Promise<String>;
}

export interface HourPreviousValuesSubscription
  extends Promise<AsyncIterator<HourPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
  hourDayMonthYear: () => Promise<AsyncIterator<String>>;
}

export interface Hour {
  id: ID_Output;
  value: Int;
  hourDayMonthYear: String;
}

export interface HourPromise extends Promise<Hour>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  hourDayMonthYear: () => Promise<String>;
  day: <T = DayPromise>() => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface HourSubscription
  extends Promise<AsyncIterator<Hour>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
  hourDayMonthYear: () => Promise<AsyncIterator<String>>;
  day: <T = DaySubscription>() => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface HourNullablePromise
  extends Promise<Hour | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  hourDayMonthYear: () => Promise<String>;
  day: <T = DayPromise>() => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LayoutXS {
  id: ID_Output;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
}

export interface LayoutXSPromise extends Promise<LayoutXS>, Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
  card: <T = CardPromise>() => T;
  grouping: <T = GroupingPromise>() => T;
}

export interface LayoutXSSubscription
  extends Promise<AsyncIterator<LayoutXS>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  w: () => Promise<AsyncIterator<Int>>;
  h: () => Promise<AsyncIterator<Int>>;
  card: <T = CardSubscription>() => T;
  grouping: <T = GroupingSubscription>() => T;
}

export interface LayoutXSNullablePromise
  extends Promise<LayoutXS | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
  card: <T = CardPromise>() => T;
  grouping: <T = GroupingPromise>() => T;
}

export interface Month {
  id: ID_Output;
  value: Int;
  monthYear: String;
}

export interface MonthPromise extends Promise<Month>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  monthYear: () => Promise<String>;
  year: <T = YearPromise>() => T;
  days: <T = FragmentableArray<Day>>(args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MonthSubscription
  extends Promise<AsyncIterator<Month>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
  monthYear: () => Promise<AsyncIterator<String>>;
  year: <T = YearSubscription>() => T;
  days: <T = Promise<AsyncIterator<DaySubscription>>>(args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MonthNullablePromise
  extends Promise<Month | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  monthYear: () => Promise<String>;
  year: <T = YearPromise>() => T;
  days: <T = FragmentableArray<Day>>(args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface Year {
  id: ID_Output;
  value: Int;
}

export interface YearPromise extends Promise<Year>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  quarters: <T = FragmentableArray<Quarter>>(args?: {
    where?: QuarterWhereInput;
    orderBy?: QuarterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  months: <T = FragmentableArray<Month>>(args?: {
    where?: MonthWhereInput;
    orderBy?: MonthOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  weeks: <T = FragmentableArray<Week>>(args?: {
    where?: WeekWhereInput;
    orderBy?: WeekOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface YearSubscription
  extends Promise<AsyncIterator<Year>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
  quarters: <T = Promise<AsyncIterator<QuarterSubscription>>>(args?: {
    where?: QuarterWhereInput;
    orderBy?: QuarterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  months: <T = Promise<AsyncIterator<MonthSubscription>>>(args?: {
    where?: MonthWhereInput;
    orderBy?: MonthOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  weeks: <T = Promise<AsyncIterator<WeekSubscription>>>(args?: {
    where?: WeekWhereInput;
    orderBy?: WeekOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface YearNullablePromise
  extends Promise<Year | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  quarters: <T = FragmentableArray<Quarter>>(args?: {
    where?: QuarterWhereInput;
    orderBy?: QuarterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  months: <T = FragmentableArray<Month>>(args?: {
    where?: MonthWhereInput;
    orderBy?: MonthOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  weeks: <T = FragmentableArray<Week>>(args?: {
    where?: WeekWhereInput;
    orderBy?: WeekOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ItemPreviousValues {
  id: ID_Output;
  type?: ItemType;
  alertID?: Int;
  logID?: String;
  triggerTime: String;
  name?: String;
  message?: String;
  level?: Level;
  source?: Source;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ItemType>;
  alertID: () => Promise<Int>;
  logID: () => Promise<String>;
  triggerTime: () => Promise<String>;
  name: () => Promise<String>;
  message: () => Promise<String>;
  level: () => Promise<Level>;
  source: () => Promise<Source>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ItemType>>;
  alertID: () => Promise<AsyncIterator<Int>>;
  logID: () => Promise<AsyncIterator<String>>;
  triggerTime: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  message: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<Level>>;
  source: () => Promise<AsyncIterator<Source>>;
}

export interface YearEdge {
  node: Year;
  cursor: String;
}

export interface YearEdgePromise extends Promise<YearEdge>, Fragmentable {
  node: <T = YearPromise>() => T;
  cursor: () => Promise<String>;
}

export interface YearEdgeSubscription
  extends Promise<AsyncIterator<YearEdge>>,
    Fragmentable {
  node: <T = YearSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LayoutSM {
  id: ID_Output;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
}

export interface LayoutSMPromise extends Promise<LayoutSM>, Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
  card: <T = CardPromise>() => T;
  grouping: <T = GroupingPromise>() => T;
}

export interface LayoutSMSubscription
  extends Promise<AsyncIterator<LayoutSM>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  w: () => Promise<AsyncIterator<Int>>;
  h: () => Promise<AsyncIterator<Int>>;
  card: <T = CardSubscription>() => T;
  grouping: <T = GroupingSubscription>() => T;
}

export interface LayoutSMNullablePromise
  extends Promise<LayoutSM | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
  card: <T = CardPromise>() => T;
  grouping: <T = GroupingPromise>() => T;
}

export interface WeekConnection {
  pageInfo: PageInfo;
  edges: WeekEdge[];
}

export interface WeekConnectionPromise
  extends Promise<WeekConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WeekEdge>>() => T;
  aggregate: <T = AggregateWeekPromise>() => T;
}

export interface WeekConnectionSubscription
  extends Promise<AsyncIterator<WeekConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WeekEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWeekSubscription>() => T;
}

export interface LayoutLGSubscriptionPayload {
  mutation: MutationType;
  node: LayoutLG;
  updatedFields: String[];
  previousValues: LayoutLGPreviousValues;
}

export interface LayoutLGSubscriptionPayloadPromise
  extends Promise<LayoutLGSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LayoutLGPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LayoutLGPreviousValuesPromise>() => T;
}

export interface LayoutLGSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LayoutLGSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LayoutLGSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LayoutLGPreviousValuesSubscription>() => T;
}

export interface AggregateMonth {
  count: Int;
}

export interface AggregateMonthPromise
  extends Promise<AggregateMonth>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMonthSubscription
  extends Promise<AsyncIterator<AggregateMonth>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LayoutLGPreviousValues {
  id: ID_Output;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
}

export interface LayoutLGPreviousValuesPromise
  extends Promise<LayoutLGPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
}

export interface LayoutLGPreviousValuesSubscription
  extends Promise<AsyncIterator<LayoutLGPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  w: () => Promise<AsyncIterator<Int>>;
  h: () => Promise<AsyncIterator<Int>>;
}

export interface LayoutXSEdge {
  node: LayoutXS;
  cursor: String;
}

export interface LayoutXSEdgePromise
  extends Promise<LayoutXSEdge>,
    Fragmentable {
  node: <T = LayoutXSPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LayoutXSEdgeSubscription
  extends Promise<AsyncIterator<LayoutXSEdge>>,
    Fragmentable {
  node: <T = LayoutXSSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LayoutMD {
  id: ID_Output;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
}

export interface LayoutMDPromise extends Promise<LayoutMD>, Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
  card: <T = CardPromise>() => T;
  grouping: <T = GroupingPromise>() => T;
}

export interface LayoutMDSubscription
  extends Promise<AsyncIterator<LayoutMD>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  w: () => Promise<AsyncIterator<Int>>;
  h: () => Promise<AsyncIterator<Int>>;
  card: <T = CardSubscription>() => T;
  grouping: <T = GroupingSubscription>() => T;
}

export interface LayoutMDNullablePromise
  extends Promise<LayoutMD | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
  card: <T = CardPromise>() => T;
  grouping: <T = GroupingPromise>() => T;
}

export interface LayoutSMConnection {
  pageInfo: PageInfo;
  edges: LayoutSMEdge[];
}

export interface LayoutSMConnectionPromise
  extends Promise<LayoutSMConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LayoutSMEdge>>() => T;
  aggregate: <T = AggregateLayoutSMPromise>() => T;
}

export interface LayoutSMConnectionSubscription
  extends Promise<AsyncIterator<LayoutSMConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LayoutSMEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLayoutSMSubscription>() => T;
}

export interface LayoutMDSubscriptionPayload {
  mutation: MutationType;
  node: LayoutMD;
  updatedFields: String[];
  previousValues: LayoutMDPreviousValues;
}

export interface LayoutMDSubscriptionPayloadPromise
  extends Promise<LayoutMDSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LayoutMDPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LayoutMDPreviousValuesPromise>() => T;
}

export interface LayoutMDSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LayoutMDSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LayoutMDSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LayoutMDPreviousValuesSubscription>() => T;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface LayoutMDPreviousValues {
  id: ID_Output;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
}

export interface LayoutMDPreviousValuesPromise
  extends Promise<LayoutMDPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
}

export interface LayoutMDPreviousValuesSubscription
  extends Promise<AsyncIterator<LayoutMDPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  w: () => Promise<AsyncIterator<Int>>;
  h: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateGrouping {
  count: Int;
}

export interface AggregateGroupingPromise
  extends Promise<AggregateGrouping>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupingSubscription
  extends Promise<AsyncIterator<AggregateGrouping>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Dashboard {
  id: ID_Output;
  name: String;
}

export interface DashboardPromise extends Promise<Dashboard>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  groupings: <T = FragmentableArray<Grouping>>(args?: {
    where?: GroupingWhereInput;
    orderBy?: GroupingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DashboardSubscription
  extends Promise<AsyncIterator<Dashboard>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  groupings: <T = Promise<AsyncIterator<GroupingSubscription>>>(args?: {
    where?: GroupingWhereInput;
    orderBy?: GroupingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DashboardNullablePromise
  extends Promise<Dashboard | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  groupings: <T = FragmentableArray<Grouping>>(args?: {
    where?: GroupingWhereInput;
    orderBy?: GroupingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EntityEdge {
  node: Entity;
  cursor: String;
}

export interface EntityEdgePromise extends Promise<EntityEdge>, Fragmentable {
  node: <T = EntityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityEdgeSubscription
  extends Promise<AsyncIterator<EntityEdge>>,
    Fragmentable {
  node: <T = EntitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LayoutSMSubscriptionPayload {
  mutation: MutationType;
  node: LayoutSM;
  updatedFields: String[];
  previousValues: LayoutSMPreviousValues;
}

export interface LayoutSMSubscriptionPayloadPromise
  extends Promise<LayoutSMSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LayoutSMPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LayoutSMPreviousValuesPromise>() => T;
}

export interface LayoutSMSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LayoutSMSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LayoutSMSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LayoutSMPreviousValuesSubscription>() => T;
}

export interface DayConnection {
  pageInfo: PageInfo;
  edges: DayEdge[];
}

export interface DayConnectionPromise
  extends Promise<DayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DayEdge>>() => T;
  aggregate: <T = AggregateDayPromise>() => T;
}

export interface DayConnectionSubscription
  extends Promise<AsyncIterator<DayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDaySubscription>() => T;
}

export interface LayoutSMPreviousValues {
  id: ID_Output;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
}

export interface LayoutSMPreviousValuesPromise
  extends Promise<LayoutSMPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
}

export interface LayoutSMPreviousValuesSubscription
  extends Promise<AsyncIterator<LayoutSMPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  w: () => Promise<AsyncIterator<Int>>;
  h: () => Promise<AsyncIterator<Int>>;
}

export interface Week {
  id: ID_Output;
  value: Int;
  weekYear: String;
}

export interface WeekPromise extends Promise<Week>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  weekYear: () => Promise<String>;
  year: <T = YearPromise>() => T;
  days: <T = FragmentableArray<Day>>(args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WeekSubscription
  extends Promise<AsyncIterator<Week>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
  weekYear: () => Promise<AsyncIterator<String>>;
  year: <T = YearSubscription>() => T;
  days: <T = Promise<AsyncIterator<DaySubscription>>>(args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WeekNullablePromise
  extends Promise<Week | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  weekYear: () => Promise<String>;
  year: <T = YearPromise>() => T;
  days: <T = FragmentableArray<Day>>(args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Grouping {
  id: ID_Output;
  title?: String;
  subtitle?: String;
  chips: String[];
}

export interface GroupingPromise extends Promise<Grouping>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  dashboard: <T = DashboardPromise>() => T;
  chips: () => Promise<String[]>;
  cards: <T = FragmentableArray<Card>>(args?: {
    where?: CardWhereInput;
    orderBy?: CardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutLGs: <T = FragmentableArray<LayoutLG>>(args?: {
    where?: LayoutLGWhereInput;
    orderBy?: LayoutLGOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutMDs: <T = FragmentableArray<LayoutMD>>(args?: {
    where?: LayoutMDWhereInput;
    orderBy?: LayoutMDOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutSMs: <T = FragmentableArray<LayoutSM>>(args?: {
    where?: LayoutSMWhereInput;
    orderBy?: LayoutSMOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutXSs: <T = FragmentableArray<LayoutXS>>(args?: {
    where?: LayoutXSWhereInput;
    orderBy?: LayoutXSOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GroupingSubscription
  extends Promise<AsyncIterator<Grouping>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  dashboard: <T = DashboardSubscription>() => T;
  chips: () => Promise<AsyncIterator<String[]>>;
  cards: <T = Promise<AsyncIterator<CardSubscription>>>(args?: {
    where?: CardWhereInput;
    orderBy?: CardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutLGs: <T = Promise<AsyncIterator<LayoutLGSubscription>>>(args?: {
    where?: LayoutLGWhereInput;
    orderBy?: LayoutLGOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutMDs: <T = Promise<AsyncIterator<LayoutMDSubscription>>>(args?: {
    where?: LayoutMDWhereInput;
    orderBy?: LayoutMDOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutSMs: <T = Promise<AsyncIterator<LayoutSMSubscription>>>(args?: {
    where?: LayoutSMWhereInput;
    orderBy?: LayoutSMOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutXSs: <T = Promise<AsyncIterator<LayoutXSSubscription>>>(args?: {
    where?: LayoutXSWhereInput;
    orderBy?: LayoutXSOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GroupingNullablePromise
  extends Promise<Grouping | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  dashboard: <T = DashboardPromise>() => T;
  chips: () => Promise<String[]>;
  cards: <T = FragmentableArray<Card>>(args?: {
    where?: CardWhereInput;
    orderBy?: CardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutLGs: <T = FragmentableArray<LayoutLG>>(args?: {
    where?: LayoutLGWhereInput;
    orderBy?: LayoutLGOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutMDs: <T = FragmentableArray<LayoutMD>>(args?: {
    where?: LayoutMDWhereInput;
    orderBy?: LayoutMDOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutSMs: <T = FragmentableArray<LayoutSM>>(args?: {
    where?: LayoutSMWhereInput;
    orderBy?: LayoutSMOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  layoutXSs: <T = FragmentableArray<LayoutXS>>(args?: {
    where?: LayoutXSWhereInput;
    orderBy?: LayoutXSOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface YearSubscriptionPayload {
  mutation: MutationType;
  node: Year;
  updatedFields: String[];
  previousValues: YearPreviousValues;
}

export interface YearSubscriptionPayloadPromise
  extends Promise<YearSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = YearPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = YearPreviousValuesPromise>() => T;
}

export interface YearSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<YearSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = YearSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = YearPreviousValuesSubscription>() => T;
}

export interface LayoutXSSubscriptionPayload {
  mutation: MutationType;
  node: LayoutXS;
  updatedFields: String[];
  previousValues: LayoutXSPreviousValues;
}

export interface LayoutXSSubscriptionPayloadPromise
  extends Promise<LayoutXSSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LayoutXSPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LayoutXSPreviousValuesPromise>() => T;
}

export interface LayoutXSSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LayoutXSSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LayoutXSSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LayoutXSPreviousValuesSubscription>() => T;
}

export interface QuarterEdge {
  node: Quarter;
  cursor: String;
}

export interface QuarterEdgePromise extends Promise<QuarterEdge>, Fragmentable {
  node: <T = QuarterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuarterEdgeSubscription
  extends Promise<AsyncIterator<QuarterEdge>>,
    Fragmentable {
  node: <T = QuarterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LayoutXSPreviousValues {
  id: ID_Output;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
}

export interface LayoutXSPreviousValuesPromise
  extends Promise<LayoutXSPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
}

export interface LayoutXSPreviousValuesSubscription
  extends Promise<AsyncIterator<LayoutXSPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  w: () => Promise<AsyncIterator<Int>>;
  h: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateLayoutSM {
  count: Int;
}

export interface AggregateLayoutSMPromise
  extends Promise<AggregateLayoutSM>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLayoutSMSubscription
  extends Promise<AsyncIterator<AggregateLayoutSM>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Card {
  id: ID_Output;
  cardType?: CardType;
  title?: String;
}

export interface CardPromise extends Promise<Card>, Fragmentable {
  id: () => Promise<ID_Output>;
  cardType: () => Promise<CardType>;
  title: () => Promise<String>;
  layoutLG: <T = LayoutLGPromise>() => T;
  layoutMD: <T = LayoutMDPromise>() => T;
  layoutSM: <T = LayoutSMPromise>() => T;
  layoutXS: <T = LayoutXSPromise>() => T;
  grouping: <T = GroupingPromise>() => T;
}

export interface CardSubscription
  extends Promise<AsyncIterator<Card>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  cardType: () => Promise<AsyncIterator<CardType>>;
  title: () => Promise<AsyncIterator<String>>;
  layoutLG: <T = LayoutLGSubscription>() => T;
  layoutMD: <T = LayoutMDSubscription>() => T;
  layoutSM: <T = LayoutSMSubscription>() => T;
  layoutXS: <T = LayoutXSSubscription>() => T;
  grouping: <T = GroupingSubscription>() => T;
}

export interface CardNullablePromise
  extends Promise<Card | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  cardType: () => Promise<CardType>;
  title: () => Promise<String>;
  layoutLG: <T = LayoutLGPromise>() => T;
  layoutMD: <T = LayoutMDPromise>() => T;
  layoutSM: <T = LayoutSMPromise>() => T;
  layoutXS: <T = LayoutXSPromise>() => T;
  grouping: <T = GroupingPromise>() => T;
}

export interface HourEdge {
  node: Hour;
  cursor: String;
}

export interface HourEdgePromise extends Promise<HourEdge>, Fragmentable {
  node: <T = HourPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HourEdgeSubscription
  extends Promise<AsyncIterator<HourEdge>>,
    Fragmentable {
  node: <T = HourSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MonthSubscriptionPayload {
  mutation: MutationType;
  node: Month;
  updatedFields: String[];
  previousValues: MonthPreviousValues;
}

export interface MonthSubscriptionPayloadPromise
  extends Promise<MonthSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MonthPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MonthPreviousValuesPromise>() => T;
}

export interface MonthSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MonthSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MonthSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MonthPreviousValuesSubscription>() => T;
}

export interface AggregateDay {
  count: Int;
}

export interface AggregateDayPromise
  extends Promise<AggregateDay>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDaySubscription
  extends Promise<AsyncIterator<AggregateDay>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MonthPreviousValues {
  id: ID_Output;
  value: Int;
  monthYear: String;
}

export interface MonthPreviousValuesPromise
  extends Promise<MonthPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  monthYear: () => Promise<String>;
}

export interface MonthPreviousValuesSubscription
  extends Promise<AsyncIterator<MonthPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
  monthYear: () => Promise<AsyncIterator<String>>;
}

export interface Quarter {
  id: ID_Output;
  value: Int;
  quarterYear: String;
}

export interface QuarterPromise extends Promise<Quarter>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  quarterYear: () => Promise<String>;
  year: <T = YearPromise>() => T;
  days: <T = FragmentableArray<Day>>(args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuarterSubscription
  extends Promise<AsyncIterator<Quarter>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
  quarterYear: () => Promise<AsyncIterator<String>>;
  year: <T = YearSubscription>() => T;
  days: <T = Promise<AsyncIterator<DaySubscription>>>(args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuarterNullablePromise
  extends Promise<Quarter | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  quarterYear: () => Promise<String>;
  year: <T = YearPromise>() => T;
  days: <T = FragmentableArray<Day>>(args?: {
    where?: DayWhereInput;
    orderBy?: DayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MonthConnection {
  pageInfo: PageInfo;
  edges: MonthEdge[];
}

export interface MonthConnectionPromise
  extends Promise<MonthConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MonthEdge>>() => T;
  aggregate: <T = AggregateMonthPromise>() => T;
}

export interface MonthConnectionSubscription
  extends Promise<AsyncIterator<MonthConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MonthEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMonthSubscription>() => T;
}

export interface WeekPreviousValues {
  id: ID_Output;
  value: Int;
  weekYear: String;
}

export interface WeekPreviousValuesPromise
  extends Promise<WeekPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  weekYear: () => Promise<String>;
}

export interface WeekPreviousValuesSubscription
  extends Promise<AsyncIterator<WeekPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
  weekYear: () => Promise<AsyncIterator<String>>;
}

export interface QuarterPreviousValues {
  id: ID_Output;
  value: Int;
  quarterYear: String;
}

export interface QuarterPreviousValuesPromise
  extends Promise<QuarterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Int>;
  quarterYear: () => Promise<String>;
}

export interface QuarterPreviousValuesSubscription
  extends Promise<AsyncIterator<QuarterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Int>>;
  quarterYear: () => Promise<AsyncIterator<String>>;
}

export interface QuarterSubscriptionPayload {
  mutation: MutationType;
  node: Quarter;
  updatedFields: String[];
  previousValues: QuarterPreviousValues;
}

export interface QuarterSubscriptionPayloadPromise
  extends Promise<QuarterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuarterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuarterPreviousValuesPromise>() => T;
}

export interface QuarterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuarterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuarterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuarterPreviousValuesSubscription>() => T;
}

export interface LayoutLG {
  id: ID_Output;
  x: Int;
  y: Int;
  w: Int;
  h: Int;
}

export interface LayoutLGPromise extends Promise<LayoutLG>, Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
  card: <T = CardPromise>() => T;
  grouping: <T = GroupingPromise>() => T;
}

export interface LayoutLGSubscription
  extends Promise<AsyncIterator<LayoutLG>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  w: () => Promise<AsyncIterator<Int>>;
  h: () => Promise<AsyncIterator<Int>>;
  card: <T = CardSubscription>() => T;
  grouping: <T = GroupingSubscription>() => T;
}

export interface LayoutLGNullablePromise
  extends Promise<LayoutLG | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  w: () => Promise<Int>;
  h: () => Promise<Int>;
  card: <T = CardPromise>() => T;
  grouping: <T = GroupingPromise>() => T;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateWeek {
  count: Int;
}

export interface AggregateWeekPromise
  extends Promise<AggregateWeek>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWeekSubscription
  extends Promise<AsyncIterator<AggregateWeek>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Item {
  id: ID_Output;
  type?: ItemType;
  alertID?: Int;
  logID?: String;
  triggerTime: String;
  name?: String;
  message?: String;
  level?: Level;
  source?: Source;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ItemType>;
  alertID: () => Promise<Int>;
  logID: () => Promise<String>;
  triggerTime: () => Promise<String>;
  name: () => Promise<String>;
  message: () => Promise<String>;
  level: () => Promise<Level>;
  source: () => Promise<Source>;
  trigger: <T = EntityPromise>() => T;
  hour: <T = HourPromise>() => T;
  day: <T = DayPromise>() => T;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ItemType>>;
  alertID: () => Promise<AsyncIterator<Int>>;
  logID: () => Promise<AsyncIterator<String>>;
  triggerTime: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  message: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<Level>>;
  source: () => Promise<AsyncIterator<Source>>;
  trigger: <T = EntitySubscription>() => T;
  hour: <T = HourSubscription>() => T;
  day: <T = DaySubscription>() => T;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ItemType>;
  alertID: () => Promise<Int>;
  logID: () => Promise<String>;
  triggerTime: () => Promise<String>;
  name: () => Promise<String>;
  message: () => Promise<String>;
  level: () => Promise<Level>;
  source: () => Promise<Source>;
  trigger: <T = EntityPromise>() => T;
  hour: <T = HourPromise>() => T;
  day: <T = DayPromise>() => T;
}

export interface GroupingConnection {
  pageInfo: PageInfo;
  edges: GroupingEdge[];
}

export interface GroupingConnectionPromise
  extends Promise<GroupingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupingEdge>>() => T;
  aggregate: <T = AggregateGroupingPromise>() => T;
}

export interface GroupingConnectionSubscription
  extends Promise<AsyncIterator<GroupingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupingSubscription>() => T;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Dashboard",
    embedded: false
  },
  {
    name: "Grouping",
    embedded: false
  },
  {
    name: "Card",
    embedded: false
  },
  {
    name: "LayoutLG",
    embedded: false
  },
  {
    name: "LayoutMD",
    embedded: false
  },
  {
    name: "LayoutSM",
    embedded: false
  },
  {
    name: "LayoutXS",
    embedded: false
  },
  {
    name: "Entity",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "Year",
    embedded: false
  },
  {
    name: "Quarter",
    embedded: false
  },
  {
    name: "Month",
    embedded: false
  },
  {
    name: "Week",
    embedded: false
  },
  {
    name: "Day",
    embedded: false
  },
  {
    name: "Hour",
    embedded: false
  },
  {
    name: "Level",
    embedded: false
  },
  {
    name: "ItemType",
    embedded: false
  },
  {
    name: "Source",
    embedded: false
  },
  {
    name: "EntityType",
    embedded: false
  },
  {
    name: "CardType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
